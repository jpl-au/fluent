// Code generated by fluent generator. DO NOT EDIT.

package input

import (
	"github.com/jpl-au/fluent/html5"
	"strconv"
	"strings"
	"bytes"
	"io"
	"github.com/jpl-au/fluent"
	"github.com/jpl-au/fluent/node"
	"github.com/jpl-au/fluent/html5/attr/accept"
	"github.com/jpl-au/fluent/html5/attr/autocomplete"
	"github.com/jpl-au/fluent/html5/attr/capture"
	"github.com/jpl-au/fluent/html5/attr/enctype"
	"github.com/jpl-au/fluent/html5/attr/formmethod"
	"github.com/jpl-au/fluent/html5/attr/inputtype"
	"github.com/jpl-au/fluent/html5/attr/popovertargetaction"
	"github.com/jpl-au/fluent/html5/attr/target"
	"github.com/jpl-au/fluent/html5/attr/autocapitalize"
	"github.com/jpl-au/fluent/html5/attr/autocorrect"
	"github.com/jpl-au/fluent/html5/attr/contenteditable"
	"github.com/jpl-au/fluent/html5/attr/dir"
	"github.com/jpl-au/fluent/html5/attr/enterkeyhint"
	"github.com/jpl-au/fluent/html5/attr/inputmode"
	"github.com/jpl-au/fluent/html5/attr/popover"
	"github.com/jpl-au/fluent/html5/attr/spellcheck"
	"github.com/jpl-au/fluent/html5/attr/translate"
	"github.com/jpl-au/fluent/html5/attr/virtualkeyboardpolicy"
	"github.com/jpl-au/fluent/html5/attr/writingsuggestions"
)

// Element is an exported alias for the private element type
type Element = element

// element represents the <input> HTML element
type element struct {
	accept accept.Accept
	autocomplete autocomplete.AutoComplete
	capture capture.Capture
	enctype enctype.EncType
	formmethod formmethod.FormMethod
	inputType inputtype.InputType
	nodes []node.Node
	popovertargetaction popovertargetaction.PopoverTargetAction
	target target.Target
	accesskey string
	class string
	exportparts string
	id string
	itemprop string
	itemref string
	lang string
	name string
	part string
	placeholder string
	role string
	src string
	style string
	title string
	value string
	attr *[]node.Attribute
	ea *html5.EventAttributes
	ga *html5.GlobalAttributes
	bufferhint int
	maxlength int
	tabindex int
	autofocus bool
	checked bool
	disabled bool
	draggable bool
	formnovalidate bool
	hidden bool
	inert bool
	itemscope bool
	multiple bool
	readonly bool
	required bool
}

// global returns the GlobalAttributes, initializing if nil
func (e *element) global() *html5.GlobalAttributes {
	if e.ga == nil {
		e.ga = &html5.GlobalAttributes{}
	}
	return e.ga
}

// event returns the EventAttributes, initializing if nil
func (e *element) event() *html5.EventAttributes {
	if e.ea == nil {
		e.ea = &html5.EventAttributes{}
	}
	return e.ea
}

// New Creates a new input element without any initial attributes.
// Example: input.New().Type(inputtype.Text).Name("username")
// Renders: <input name="username" type="text" />
func New() *element {
	return &element{}
}

// Text Creates a text input field for single-line text entry.
// Example: input.Text("title", "Mr")
// Renders: <input name="title" value="Mr" type="text" />
func Text(name string, value string) *element {
	return &element{
		inputType: inputtype.Text,
		name: name,
		value: value,
	}
}

// Password Creates a password input field that obscures entered characters.
// Example: input.Password("password")
// Renders: <input name="password" type="password" />
func Password(name string) *element {
	return &element{
		inputType: inputtype.Password,
		name: name,
	}
}

// Email Creates an email input field with automatic email validation.
// Example: input.Email("email")
// Renders: <input name="email" type="email" />
func Email(name string) *element {
	return &element{
		inputType: inputtype.Email,
		name: name,
	}
}

// Search Creates a search input field optimised for search queries.
// Example: input.Search("query")
// Renders: <input name="query" type="search" />
func Search(name string) *element {
	return &element{
		inputType: inputtype.Search,
		name: name,
	}
}

// Tel Creates a telephone number input field.
// Example: input.Tel("phone")
// Renders: <input name="phone" type="tel" />
func Tel(name string) *element {
	return &element{
		inputType: inputtype.Tel,
		name: name,
	}
}

// URL Creates a URL input field with URL validation.
// Example: input.URL("website")
// Renders: <input name="website" type="url" />
func URL(name string) *element {
	return &element{
		inputType: inputtype.Url,
		name: name,
	}
}

// Number Creates a numeric input field with spinner controls.
// Example: input.Number("quantity")
// Renders: <input name="quantity" type="number" />
func Number(name string) *element {
	return &element{
		inputType: inputtype.Number,
		name: name,
	}
}

// Range Creates a range slider input for selecting numeric values.
// Example: input.Range("volume")
// Renders: <input name="volume" type="range" />
func Range(name string) *element {
	return &element{
		inputType: inputtype.Range,
		name: name,
	}
}

// Date Creates a date picker input field.
// Example: input.Date("birthday")
// Renders: <input name="birthday" type="date" />
func Date(name string) *element {
	return &element{
		inputType: inputtype.Date,
		name: name,
	}
}

// Time Creates a time picker input field.
// Example: input.Time("appointment")
// Renders: <input name="appointment" type="time" />
func Time(name string) *element {
	return &element{
		inputType: inputtype.Time,
		name: name,
	}
}

// DateTimeLocal Creates a local date and time picker input field.
// Example: input.DateTimeLocal("meeting")
// Renders: <input name="meeting" type="datetime-local" />
func DateTimeLocal(name string) *element {
	return &element{
		inputType: inputtype.DatetimeLocal,
		name: name,
	}
}

// Month Creates a month picker input field.
// Example: input.Month("expiry")
// Renders: <input name="expiry" type="month" />
func Month(name string) *element {
	return &element{
		inputType: inputtype.Month,
		name: name,
	}
}

// Week Creates a week picker input field.
// Example: input.Week("schedule")
// Renders: <input name="schedule" type="week" />
func Week(name string) *element {
	return &element{
		inputType: inputtype.Week,
		name: name,
	}
}

// Checkbox Creates a checkbox input for boolean or multi-select options.
// Example: input.Checkbox("agree", "yes")
// Renders: <input name="agree" value="yes" type="checkbox" />
func Checkbox(name string, value string) *element {
	return &element{
		inputType: inputtype.Checkbox,
		name: name,
		value: value,
	}
}

// Radio Creates a radio button input for exclusive selection within a group.
// Example: input.Radio("gender", "male")
// Renders: <input name="gender" value="male" type="radio" />
func Radio(name string, value string) *element {
	return &element{
		inputType: inputtype.Radio,
		name: name,
		value: value,
	}
}

// File Creates a file upload input for selecting local files.
// Example: input.File("avatar")
// Renders: <input name="avatar" type="file" />
func File(name string) *element {
	return &element{
		inputType: inputtype.File,
		name: name,
	}
}

// Submit Creates a submit button input for form submission.
// Example: input.Submit("Submit Form")
// Renders: <input value="Submit Form" type="submit" />
func Submit(value string) *element {
	return &element{
		inputType: inputtype.Submit,
		value: value,
	}
}

// Button Creates a button input with no default behaviour.
// Example: input.Button("Click Me")
// Renders: <input value="Click Me" type="button" />
func Button(value string) *element {
	return &element{
		inputType: inputtype.Button,
		value: value,
	}
}

// Reset Creates a reset button input that clears form values.
// Example: input.Reset("Clear Form")
// Renders: <input value="Clear Form" type="reset" />
func Reset(value string) *element {
	return &element{
		inputType: inputtype.Reset,
		value: value,
	}
}

// Hidden Creates a hidden input field not visible to users.
// Example: input.Hidden("csrf_token", "abc123")
// Renders: <input name="csrf_token" value="abc123" type="hidden" />
func Hidden(name string, value string) *element {
	return &element{
		inputType: inputtype.Hidden,
		name: name,
		value: value,
	}
}

// Color Creates a colour picker input field.
// Example: input.Color("theme")
// Renders: <input name="theme" type="color" />
func Color(name string) *element {
	return &element{
		inputType: inputtype.Color,
		name: name,
	}
}

// Image Creates an image submit button with graphical representation.
// Example: input.Image("submit", "/images/submit.png")
// Renders: <input name="submit" type="image" src="/images/submit.png" />
func Image(name string, src string) *element {
	return &element{
		inputType: inputtype.Image,
		name: name,
		src: src,
	}
}


// Name Specifies the name of the input control, which is used to identify the field when form data is submitted to the server. The name attribute is essential for form processing and must be unique within the form context (except for radio buttons that should share the same name to form a group). This value becomes the key in form data when submitted.
func (e *element) Name(name string) *element {
	e.name = name
	return e
}

// Value Defines the initial value of the input control. For text-based inputs, this sets the default text displayed in the field. For buttons, it defines the text shown on the button. For checkboxes and radio buttons, it specifies the value that will be submitted if the control is selected. The value can be changed by user interaction or JavaScript.
func (e *element) Value(value string) *element {
	e.value = value
	return e
}

// Type Determines the type of input control to display and how it behaves. This fundamentally changes the input's appearance and functionality. Common types include 'text' (default), 'password', 'email', 'number', 'date', 'checkbox', 'radio', 'file', 'submit', 'button', and many others. Each type has its own validation rules and user interface.
func (e *element) Type(inputType inputtype.InputType) *element {
	e.inputType = inputType
	return e
}

// Src Valid only for image input type, this attribute specifies the URL of the image to display on the submit button. The image serves as both a visual element and a functional submit button. If the image fails to load, the alt text is displayed instead. The image should clearly indicate its purpose as a clickable submit control to users.
func (e *element) Src(url string) *element {
	e.src = url
	return e
}

// Accept Valid only for file input type, this attribute defines which file types are selectable in a file upload control. It accepts MIME types (like 'image/png'), file extensions (like '.jpg'), or wildcards (like 'image/*'). Multiple values can be specified using commas. This provides a filter in the file selection dialog and helps users choose appropriate files.
func (e *element) Accept(types ...accept.Accept) *element {
	if len(types) == 0 {
		return e
	}
	if len(e.accept) == 0 {
		for i, item := range types {
			if i > 0 {
				e.accept = append(e.accept, ", "...)
			}
			e.accept = append(e.accept, item...)
		}
	} else {
		e.accept = append(e.accept, ", "...)
		for i, item := range types {
			if i > 0 {
				e.accept = append(e.accept, ", "...)
			}
			e.accept = append(e.accept, item...)
		}
	}
	return e
}

// Alt Valid only for image input type, this attribute provides alternative text for the image. It displays if the image source is missing or fails to load, and is crucial for accessibility as screen readers use this text to describe the image to users with visual impairments. The text should concisely describe the image's purpose or content.
func (e *element) Alt(text string) *element {
	e.SetAttribute("alt", text)
	return e
}

// AutoComplete Controls the browser's autocomplete behavior for the input field. Values include 'on' (default), 'off', or specific autocomplete tokens like 'name', 'email', 'current-password', 'new-password', 'address-line1', etc. This helps browsers provide relevant suggestions and assists users in filling forms more quickly while maintaining security for sensitive fields.
func (e *element) AutoComplete(value autocomplete.AutoComplete) *element {
	e.autocomplete = value
	return e
}

// Capture Valid only for file input type with accept attribute that includes image or video, this attribute specifies which camera to use for capturing media directly. Values include 'user' (front-facing camera), 'environment' (rear-facing camera), or a boolean to allow any camera. This enables direct photo/video capture on mobile devices without requiring users to select from existing files.
func (e *element) Capture(value capture.Capture) *element {
	e.capture = value
	return e
}

// Checked Valid only for checkbox and radio input types, this boolean attribute indicates whether the control is selected by default when the page loads. For checkboxes, it determines the initial checked state. For radio buttons, only one radio button in a group (same name) should be checked initially. This state can be changed through user interaction or JavaScript.
func (e *element) Checked() *element {
	e.checked = true
	return e
}

// DirName Enables automatic submission of the text directionality (left-to-right or right-to-left) of the element's content along with the form data. When specified, the browser includes an additional field with this name containing the directionality value ('ltr' or 'rtl'). This is particularly useful for international applications that need to track text direction for proper display and processing.
func (e *element) DirName(name string) *element {
	e.SetAttribute("dirname", name)
	return e
}

// Disabled When present, this boolean attribute indicates that the input control is disabled and cannot be interacted with by users. Disabled controls appear greyed out, don't receive focus, aren't included in form submission, and can't be modified. This is useful for temporarily preventing user input or indicating unavailable options while maintaining the field's visibility in the form layout.
func (e *element) Disabled() *element {
	e.disabled = true
	return e
}

// Form Associates the input with a specific form element by referencing the form's ID attribute. This allows the input to be part of a form even when it's not physically located inside the form element in the HTML structure. This is particularly useful for complex layouts where form controls need to be positioned separately from the main form element while maintaining logical association.
func (e *element) Form(formID string) *element {
	e.SetAttribute("form", formID)
	return e
}

// FormAction Valid only for submit and image input types, this attribute specifies an alternative URL for form submission, overriding the form's action attribute. This allows different submit buttons to send form data to different endpoints, enabling scenarios like 'Save' vs 'Save and Continue' buttons or multiple processing paths from a single form.
func (e *element) FormAction(url string) *element {
	e.SetAttribute("formaction", url)
	return e
}

// FormEncType Valid only for submit and image input types, this attribute specifies how form data should be encoded when submitted, overriding the form's enctype attribute. Common values include 'application/x-www-form-urlencoded' (default), 'multipart/form-data' (required for file uploads), and 'text/plain'. This allows different submit buttons to use different encoding methods as needed.
func (e *element) FormEncType(enctype enctype.EncType) *element {
	e.enctype = enctype
	return e
}

// FormMethod Valid only for submit and image input types, this attribute specifies the HTTP method for form submission, overriding the form's method attribute. Values are typically 'GET' or 'POST', with 'GET' appending data to the URL and 'POST' sending data in the request body. This enables different submit actions to use appropriate HTTP methods for their specific purposes.
func (e *element) FormMethod(method formmethod.FormMethod) *element {
	e.formmethod = method
	return e
}

// FormNoValidate Valid only for submit and image input types, this boolean attribute indicates that form validation should be bypassed when the form is submitted via this control. This overrides the form's validation behavior, allowing submission of forms that might contain invalid data. This is useful for 'Save Draft' functionality or when validation should be performed server-side instead.
func (e *element) FormNoValidate() *element {
	e.formnovalidate = true
	return e
}

// FormTarget Valid only for submit and image input types, this attribute specifies where to display the response after form submission, overriding the form's target attribute. Values include '_self' (same frame), '_blank' (new window/tab), '_parent' (parent frame), '_top' (full window), or a named frame/window. This allows different submit buttons to control where their responses appear.
func (e *element) FormTarget(target target.Target) *element {
	e.target = target
	return e
}

// Height Valid only for image input type, this attribute specifies the height of the image in pixels. Along with the width attribute, it helps browsers allocate the correct space for the image before it loads, preventing layout shifts. While CSS is generally preferred for styling, this attribute provides semantic meaning for the image dimensions within the form context.
func (e *element) Height(height int) *element {
	e.SetAttribute("height", strconv.Itoa(height))
	return e
}

// List Associates the input with a datalist element by referencing its ID, providing a list of predefined options that users can choose from. This creates an autocomplete dropdown that helps users select from common values while still allowing custom input. The datalist provides suggestions but doesn't restrict input to only those values, offering flexibility while improving user experience.
func (e *element) List(datalistId string) *element {
	e.SetAttribute("list", datalistId)
	return e
}

// Max Specifies the maximum value for numeric, date, and time input types. For numbers, it sets the highest acceptable value. For dates and times, it defines the latest allowed date/time. The browser uses this for validation and may provide UI cues. Values must be in the format appropriate for the input type (numbers for numeric inputs, ISO date strings for date inputs, etc.).
func (e *element) Max(max string) *element {
	e.SetAttribute("max", max)
	return e
}

// MaxLength Defines the maximum number of characters that can be entered in text-based input types (text, password, search, tel, url, email). The browser enforces this limit during user input and validates it during form submission. This helps prevent excessively long input and can be used to match database field constraints or business rules for data length.
func (e *element) MaxLength(length int) *element {
	e.maxlength = length
	return e
}

// Min Specifies the minimum value for numeric, date, and time input types. For numbers, it sets the lowest acceptable value. For dates and times, it defines the earliest allowed date/time. This is used for validation and may affect the input's UI controls. Values must match the format expected by the input type and work together with the max attribute to define valid ranges.
func (e *element) Min(min string) *element {
	e.SetAttribute("min", min)
	return e
}

// MinLength Defines the minimum number of characters required in text-based input types before the input is considered valid. Unlike maxlength which prevents further input, minlength allows shorter input but marks it as invalid during validation. This is useful for enforcing password complexity, ensuring meaningful text input, or meeting data quality requirements.
func (e *element) MinLength(length int) *element {
	e.SetAttribute("minlength", strconv.Itoa(length))
	return e
}

// Multiple Valid for email and file input types, this boolean attribute allows multiple values to be entered or selected. For email inputs, users can enter multiple email addresses separated by commas. For file inputs, users can select multiple files simultaneously. This attribute significantly changes the input's behavior and the format of submitted data.
func (e *element) Multiple() *element {
	e.multiple = true
	return e
}

// Pattern Specifies a regular expression that the input's value must match for the input to be considered valid. This provides client-side validation for text-based inputs, allowing complex validation rules like specific formats for phone numbers, postal codes, or custom identifiers. The pattern is checked during form validation and can provide immediate feedback to users about input format requirements.
func (e *element) Pattern(regex string) *element {
	e.SetAttribute("pattern", regex)
	return e
}

// Placeholder Provides a hint or example text that appears in the input field when it's empty, helping users understand what type of information is expected. The placeholder text disappears when the user starts typing and should not replace proper labeling. It should be concise, descriptive, and provide an example of valid input format rather than instructions or labels.
func (e *element) Placeholder(text string) *element {
	e.placeholder = text
	return e
}

// PopoverTarget Transforms the input into a popover control button by specifying the ID of the element that should be shown or hidden when the input is interacted with. This creates a connection between the input and a popover element, enabling the input to trigger popover display. This is part of the modern web platform's native popover functionality for creating overlay content.
func (e *element) PopoverTarget(elementID string) *element {
	e.SetAttribute("popovertarget", elementID)
	return e
}

// PopoverTargetAction Used in conjunction with popoverTarget, this attribute specifies the action to perform on the targeted popover element. Valid values include 'toggle' (default - show if hidden, hide if shown), 'show' (only show the popover), and 'hide' (only hide the popover). This provides fine-grained control over popover behavior and enables different inputs to perform different actions on the same popover.
func (e *element) PopoverTargetAction(action popovertargetaction.PopoverTargetAction) *element {
	e.popovertargetaction = action
	return e
}

// ReadOnly When present, this boolean attribute indicates that the input's value cannot be modified by user interaction, though it remains focusable and its value is included in form submission. Unlike disabled inputs, readonly inputs can receive focus and are part of the tab order. This is useful for displaying calculated values, showing data that shouldn't be changed, or creating inputs that are conditionally editable.
func (e *element) ReadOnly() *element {
	e.readonly = true
	return e
}

// Required This boolean attribute indicates that the input must have a value before the form can be submitted. The browser will prevent form submission and typically display an error message if required fields are empty. This provides built-in client-side validation and helps ensure that essential data is collected. Required fields are often marked visually with asterisks or other indicators.
func (e *element) Required() *element {
	e.required = true
	return e
}

// Size Specifies the visible width of text-based input controls in average character widths. While this provides a rough guide for the input's display size, it doesn't limit the amount of text that can be entered (use maxlength for that). Modern web development typically uses CSS for more precise sizing, but this attribute remains useful for quick sizing without stylesheets.
func (e *element) Size(size int) *element {
	e.SetAttribute("size", strconv.Itoa(size))
	return e
}

// Step Defines the granularity that numeric, date, and time input values must adhere to. For numbers, it specifies the increment between valid values. For dates and times, it defines the allowed intervals. The value 'any' removes stepping restrictions. This affects validation, browser UI controls (like spinners), and helps ensure data consistency with expected precision levels.
func (e *element) Step(step string) *element {
	e.SetAttribute("step", step)
	return e
}

// Width Valid only for image input type, this attribute specifies the width of the image in pixels. Combined with the height attribute, it helps browsers allocate appropriate space and prevent layout shifts during image loading. While CSS is generally preferred for styling, this attribute provides semantic information about the intended display dimensions of the form's image button.
func (e *element) Width(width int) *element {
	e.SetAttribute("width", strconv.Itoa(width))
	return e
}

// Class A space-separated list of CSS class names assigned to the element. Classes are the primary mechanism for
// styling elements with CSS and selecting elements with JavaScript. Multiple classes can be applied to create
// flexible, reusable styling systems and enable complex element selection patterns. Essential for
// component-based architectures and maintainable CSS.
func (e *element) Class(class string) *element {
	if e.class == "" {
		e.class = class
	} else {
		e.class = strings.Join([]string{e.class, class}, " ")
	}
	return e
}

// ID Defines a unique identifier that must be unique across the entire document. Used for fragment navigation
// (URL anchors), JavaScript element selection, CSS styling with ID selectors, form label associations, and
// ARIA relationships. IDs have higher CSS specificity than classes and should be used sparingly for truly
// unique elements.
func (e *element) ID(id string) *element {
	e.id = id
	return e
}

// Style Contains inline CSS declarations applied directly to the element with the highest specificity. While convenient
// for dynamic styling and testing, inline styles should be used sparingly as they override external stylesheets
// and make maintenance difficult. Best used for programmatically generated styles, dynamic values, or critical
// above-the-fold styling.
func (e *element) Style(css string) *element {
	if e.style == "" {
		e.style = css
	} else {
		e.style = strings.Join([]string{e.style, css}, "; ")
	}
	return e
}

// Title Contains a text representing advisory information related to the element it belongs to. Such information can
// typically, but not necessarily, be presented to the user as a tooltip.
func (e *element) Title(text string) *element {
	e.title = text
	return e
}

// Hidden An enumerated attribute indicating that the element is not yet, or is no longer, relevant. For example, it can
// be used to hide elements of the page that can't be used until the login process has been completed. The
// browser won't render such elements. This attribute must not be used to hide content that could legitimately
// be shown.
func (e *element) Hidden() *element {
	e.hidden = true
	return e
}

// TabIndex An integer attribute indicating if the element can take input focus (is focusable), if it should participate to
// sequential keyboard navigation, and if so, at what position. It can take several values: a negative value, 0, or
// a positive value.
func (e *element) TabIndex(index int) *element {
	e.tabindex = index
	return e
}

// Role Roles define the semantic meaning of content, allowing screen readers and other tools to present and support
// interaction with an object in a way that is consistent with user expectations of that type of object. roles
// are added to HTML elements using role="role_type", where role_type is the name of a role in the ARIA
// specification.
func (e *element) Role(role string) *element {
	e.role = role
	return e
}

// Lang Helps define the language of an element the language that non-editable elements are in, or the language that
// editable elements should be written in by the user.
func (e *element) Lang(language string) *element {
	e.lang = language
	return e
}

// AccessKey Defines keyboard shortcuts for quick element access, typically activated with Alt+key (varies by browser/OS).
// Accepts space-separated characters, with browsers using the first available key on the current keyboard layout.
// Essential for accessibility and power-user workflows, but should be used thoughtfully to avoid conflicts with
// browser/OS shortcuts.
func (e *element) AccessKey(key string) *element {
	if e.accesskey == "" {
		e.accesskey = key
	} else {
		e.accesskey = strings.Join([]string{e.accesskey, key}, " ")
	}
	return e
}

// Anchor Associates a positioned element with an anchor element for CSS anchor positioning. The value references the ID
// of the element to anchor to, enabling dynamic positioning that follows the anchor element. Part of the CSS
// Anchor Positioning specification, useful for tooltips, popovers, and contextual UI elements that need to stay
// connected to their reference points.
func (e *element) Anchor(id string) *element {
	e.SetAttribute("anchor", id)
	return e
}

// AriaLabel Provides an accessible label for the element that overrides any other labeling (such as text content or
// associated label elements). This is essential for accessibility when the visible text doesn't adequately
// describe the element's purpose. Screen readers and other assistive technologies use this as the primary label
// for the element.
func (e *element) AriaLabel(label string) *element {
	e.global().AriaLabel = label
	return e
}

// SetAria Sets ARIA (Accessible Rich Internet Applications) attributes that provide semantic meaning to elements for
// assistive technologies. ARIA attributes describe element roles, properties, and states that help screen
// readers and other accessibility tools understand and interact with dynamic web content. Essential for creating
// accessible web applications.
func (e *element) SetAria(key string, value string) *element {
	e.SetAttribute("aria-" + key, value)
	return e
}

// AutoCapitalize Controls automatic text capitalization on virtual keyboards (mobile devices). Improves mobile user experience
// by reducing manual capitalization, especially useful for forms collecting names, addresses, and titles.
// Possible values: off, none, on, sentences, words, characters.
func (e *element) AutoCapitalize(value autocapitalize.AutoCapitalize) *element {
	e.global().AutoCapitalize = value
	return e
}

// AutoCorrect Controls automatic spell-checking and text correction on mobile devices and some browsers. Useful for disabling
// corrections in fields where technical terms, codes, or names are entered, or where user input should remain
// exactly as typed.
// Possible values: on, off.
func (e *element) AutoCorrect(value autocorrect.AutoCorrect) *element {
	e.global().AutoCorrect = value
	return e
}

// AutoFocus Automatically focuses the element when the page loads or when a dialog containing it is displayed. Should be
// used sparingly as it can interfere with accessibility tools and user navigation expectations. Most effective
// on primary input fields in forms or search boxes where immediate input is expected. Only one element per
// document should have autofocus.
func (e *element) AutoFocus() *element {
	e.autofocus = true
	return e
}

// ContentEditable An enumerated attribute indicating if the element should be editable by the user. If so, the browser modifies
// its widget to allow editing.
// Possible values: true, false, plaintext-only.
func (e *element) ContentEditable(value contenteditable.ContentEditable) *element {
	e.global().ContentEditable = value
	return e
}

// SetData Forms a class of attributes, called custom data attributes, that allow proprietary information to be exchanged
// between the HTML and its DOM representation that may be used by scripts. All such custom data are available
// via the HTMLElement interface of the element the attribute is set on. The HTMLElement.dataset property gives
// access to them.
func (e *element) SetData(key string, value string) *element {
	e.SetAttribute("data-" + key, value)
	return e
}

// Dir An enumerated attribute indicating the directionality of the element's text.
// Possible values: ltr, rtl, auto.
func (e *element) Dir(direction dir.Dir) *element {
	e.global().Dir = direction
	return e
}

// Draggable An enumerated attribute indicating whether the element can be dragged, using the Drag and Drop API.
// Possible values: true, false.
func (e *element) Draggable() *element {
	e.draggable = true
	return e
}

// EnterKeyHint Hints what action label (or icon) to present for the enter key on virtual keyboards.
// Possible values: enter, done, go, next, previous, search, send.
func (e *element) EnterKeyHint(hint enterkeyhint.EnterKeyHint) *element {
	e.global().EnterKeyHint = hint
	return e
}

// ExportParts Used to transitively export shadow parts from a nested shadow tree into a containing light tree.
func (e *element) ExportParts(parts string) *element {
	e.exportparts = parts
	return e
}

// Inert A boolean value that makes the browser disregard user input events for the element. Useful when click events are
// present.
func (e *element) Inert() *element {
	e.inert = true
	return e
}

// InputMode Provides a hint to browsers about the type of virtual keyboard configuration to use when editing this element
// or its contents. Used primarily on <input> elements, but is usable on any element while in contenteditable
// mode.
// Possible values: none, text, tel, url, email, numeric, decimal, search.
func (e *element) InputMode(mode inputmode.InputMode) *element {
	e.global().InputMode = mode
	return e
}

// Is Allows you to specify that a standard HTML element should behave like a registered custom built-in element.
func (e *element) Is(element string) *element {
	e.SetAttribute("is", element)
	return e
}

// ItemId The unique, global identifier of an item. This attribute is part of the WHATWG HTML Microdata feature.
func (e *element) ItemId(id string) *element {
	e.SetAttribute("itemid", id)
	return e
}

// ItemProp Used to add properties to an item. Every HTML element may have an itemprop attribute specified, where an
// itemprop consists of a name and value pair.
func (e *element) ItemProp(properties string) *element {
	e.itemprop = properties
	return e
}

// ItemRef Properties that are not descendants of an element with the itemscope attribute can be associated with the item
// using an itemref.
func (e *element) ItemRef(refs string) *element {
	e.itemref = refs
	return e
}

// ItemScope itemscope (usually) works along with itemtype to specify that the HTML contained in a block is about a
// particular item.
func (e *element) ItemScope() *element {
	e.itemscope = true
	return e
}

// ItemType Specifies the URL of the vocabulary that will be used to define itemprops (item properties) in the data
// structure.
func (e *element) ItemType(itemType string) *element {
	e.SetAttribute("itemtype", itemType)
	return e
}

// Nonce A cryptographic nonce ("number used once") which can be used by Content Security Policy to determine whether
// or not a given fetch will be allowed to proceed.
func (e *element) Nonce(value string) *element {
	e.SetAttribute("nonce", value)
	return e
}

// Part A space-separated list of the part names of the element. Part names allows CSS to select and style specific
// elements in a shadow tree via the ::part pseudo-element.
func (e *element) Part(names string) *element {
	if e.part == "" {
		e.part = names
	} else {
		e.part = strings.Join([]string{e.part, names}, " ")
	}
	return e
}

// Popover Used to designate an element as a popover element. Popover elements are hidden via display: none until opened
// via an invoking/control element (i.e., a <button> or <input type="button"> with a popovertarget attribute)
// or a HTMLElement.showPopover() call.
// Possible values: auto, manual.
func (e *element) Popover(value popover.Popover) *element {
	e.global().Popover = value
	return e
}

// Slot Assigns a slot in a shadow DOM shadow tree to an element: An element with a slot attribute is assigned to the
// slot created by the <slot> element whose name attribute's value matches that slot attribute's value.
func (e *element) Slot(name string) *element {
	e.SetAttribute("slot", name)
	return e
}

// SpellCheck An enumerated attribute that defines whether the element may be checked for spelling errors.
// Possible values: true, false.
func (e *element) SpellCheck(value spellcheck.Spellcheck) *element {
	e.global().SpellCheck = value
	return e
}

// Translate An enumerated attribute that is used to specify whether an element's attribute values and the values of its
// Text node children are to be translated when the page is localized, or whether to leave them unchanged.
// Possible values: yes, no.
func (e *element) Translate(value translate.Translate) *element {
	e.global().Translate = value
	return e
}

// VirtualKeyboardPolicy An enumerated attribute used to control the on-screen virtual keyboard behavior on devices such as tablets,
// mobile phones, or other devices where a hardware keyboard may not be available for elements that its content
// is editable (for example, it is an <input> or <textarea> element, or an element with the contenteditable
// attribute set).
// Possible values: auto, manual.
func (e *element) VirtualKeyboardPolicy(policy virtualkeyboardpolicy.VirtualKeyboardPolicy) *element {
	e.global().VirtualKeyboardPolicy = policy
	return e
}

// WritingSuggestions An enumerated attribute indicating if browser-provided writing suggestions should be enabled under the scope of
// the element or not.
// Possible values: true, false.
func (e *element) WritingSuggestions(value writingsuggestions.WritingSuggestions) *element {
	e.global().WritingSuggestions = value
	return e
}

// OnClick Fired when an element is clicked with a pointing device (mouse, trackpad, or touch). The most commonly used event for
// user interactions, triggering actions like navigation, form submission, modal opening, or any interactive behavior.
// Available on virtually all elements, making it the primary event for user interface interactions.
func (e *element) OnClick(handler string) *element {
	e.event().OnClick = handler
	return e
}

// OnChange Fired when the value of a form control has been committed by the user and the element loses focus. Differs from
// oninput which fires on every keystroke. Used on <input>, <select>, and <textarea> elements for form validation,
// data processing, dependent field updates, and saving draft changes. Essential for form workflows and user input
// handling.
func (e *element) OnChange(handler string) *element {
	e.event().OnChange = handler
	return e
}

// OnInput Fired immediately when the value of an input element changes (every keystroke, paste, etc.). Unlike onchange, it
// fires before the element loses focus. Used on <input>, <select>, and <textarea> for real-time validation,
// auto-save, search suggestions, character counters, or live form updates. Perfect for responsive user interfaces.
func (e *element) OnInput(handler string) *element {
	e.event().OnInput = handler
	return e
}

// OnFocus Fired when an element receives focus, typically through clicking, tabbing, or programmatic focus(). Commonly used
// on form elements to show input helpers, highlight fields, display validation messages, auto-select content, or
// trigger contextual UI changes. Essential for accessibility and guided user experiences.
func (e *element) OnFocus(handler string) *element {
	e.event().OnFocus = handler
	return e
}

// OnBlur Fired when an element loses focus, typically when the user clicks elsewhere or tabs to another element. Commonly
// used on form inputs (<input>, <textarea>, <select>) to validate input, save drafts, hide dropdowns, or trigger
// field-specific actions. Essential for form validation workflows and user experience enhancements.
func (e *element) OnBlur(handler string) *element {
	e.event().OnBlur = handler
	return e
}

// OnSubmit Fired when a form is submitted, either by clicking a submit button or pressing Enter in a form field. Occurs on
// <form> elements and provides the last opportunity to validate data, prevent submission with preventDefault(), show
// loading states, or perform custom submission handling like AJAX requests.
func (e *element) OnSubmit(handler string) *element {
	e.event().OnSubmit = handler
	return e
}

// OnLoad Fired when a resource and all its dependencies have finished loading successfully. Commonly used on images,
// scripts, stylesheets, iframes, and the window object. Essential for initializing functionality, showing content,
// removing loading indicators, starting animations, or executing code that depends on loaded resources.
func (e *element) OnLoad(handler string) *element {
	e.SetAttribute("onload", handler)
	return e
}

// OnError Fired when an error occurs during resource loading or processing. Common on images, scripts, stylesheets, media
// elements, and other resources that can fail to load. Essential for error handling, showing fallback content,
// implementing retry logic, logging failures, or providing user-friendly error messages when resources are
// unavailable.
func (e *element) OnError(handler string) *element {
	e.SetAttribute("onerror", handler)
	return e
}

// SetEvent Generic method to add an event using SetEvent(key, value)
func (e *element) SetEvent(key string, value string) *element {
	e.SetAttribute(key, value)
	return e
}

// OnAbort Fired when loading of a resource (image, audio, video, or other media) has been aborted before it completed
// successfully. This occurs when the user navigates away from the page, cancels the download, or when the loading
// is interrupted programmatically. Commonly used on media elements (<audio>, <video>), images (<img>), and objects
// (<object>) to handle interrupted loading states and clean up resources.
func (e *element) OnAbort(handler string) *element {
	e.SetAttribute("onabort", handler)
	return e
}

// OnAutoComplete Fired when an input field's autocomplete functionality successfully provides a suggestion that the user accepts.
// This occurs on <input> elements with autocomplete="on" when the browser's autocomplete dropdown is used to fill
// the field. Useful for tracking user interaction with browser autocomplete features, form analytics, and
// implementing custom behavior when autocomplete values are selected.
func (e *element) OnAutoComplete(handler string) *element {
	e.SetAttribute("onautocomplete", handler)
	return e
}

// OnAutoCompleteError Fired when an input field's autocomplete functionality encounters an error while attempting to provide
// suggestions. This occurs on <input> elements with autocomplete="on" when the browser fails to retrieve or
// process autocomplete data. Useful for error handling in forms, fallback autocomplete implementations, and
// debugging autocomplete issues.
func (e *element) OnAutoCompleteError(handler string) *element {
	e.SetAttribute("onautocompleteerror", handler)
	return e
}

// OnCancel Fired when a <dialog> element is cancelled, typically by pressing the Escape key. This event allows you to handle
// dialog cancellation gracefully, perform cleanup operations, reset form state, or prevent the dialog from closing
// by calling preventDefault(). Useful for confirming unsaved changes before closing modal dialogs.
func (e *element) OnCancel(handler string) *element {
	e.SetAttribute("oncancel", handler)
	return e
}

// OnCanPlay Fired when enough media data has been loaded to begin playback, but not necessarily to play through to the end
// without buffering. Occurs on <audio> and <video> elements when the media is ready to start playing. Useful for
// showing play buttons, enabling media controls, preloading indicators, or triggering autoplay functionality.
func (e *element) OnCanPlay(handler string) *element {
	e.SetAttribute("oncanplay", handler)
	return e
}

// OnCanPlayThrough Fired when enough media data has been loaded to play through to the end without interruption for buffering.
// Occurs on <audio> and <video> elements when the entire media file can be played smoothly. Ideal for hiding
// loading spinners, enabling higher quality playback options, or triggering seamless media experiences.
func (e *element) OnCanPlayThrough(handler string) *element {
	e.SetAttribute("oncanplaythrough", handler)
	return e
}

// OnClose Fired when a <dialog> element is closed, either programmatically or by user action. Unlike oncancel, this event
// fires for all dialog closing methods (close button, form submission, JavaScript close()). Useful for cleanup
// operations, saving dialog state, triggering follow-up actions, or updating the parent page based on dialog
// results.
func (e *element) OnClose(handler string) *element {
	e.SetAttribute("onclose", handler)
	return e
}

// OnContextMenu Fired when the user attempts to open a context menu, typically via right-click, Shift+F10, or long-press on
// touch devices. Can be prevented with preventDefault() to implement custom context menus. Commonly used for
// creating application-specific menus, disabling right-click functionality, or providing contextual actions based
// on the target element.
func (e *element) OnContextMenu(handler string) *element {
	e.SetAttribute("oncontextmenu", handler)
	return e
}

// OnCueChange Fired when the active cues of a TextTrack change, typically in video subtitles, captions, or chapter markers.
// Occurs on <track> elements when different text cues become active during media playback. Useful for implementing
// custom subtitle styling, accessibility features, chapter navigation, or synchronized content based on video
// timestamps.
func (e *element) OnCueChange(handler string) *element {
	e.SetAttribute("oncuechange", handler)
	return e
}

// OnDblClick Fired when an element is double-clicked rapidly (two clicks in quick succession). Commonly used for actions like
// opening files, editing text in place, zooming, or toggling between states. Note that ondblclick typically
// prevents the second onclick event from firing, making it suitable for distinct double-click actions.
func (e *element) OnDblClick(handler string) *element {
	e.SetAttribute("ondblclick", handler)
	return e
}

// OnDrag Fired repeatedly (every few hundred milliseconds) during a drag operation while the user is dragging an element.
// Used on draggable elements to provide visual feedback, update drag ghost images, track drag progress, or
// implement custom drag behaviors. Essential for smooth drag-and-drop interfaces and interactive element
// manipulation.
func (e *element) OnDrag(handler string) *element {
	e.SetAttribute("ondrag", handler)
	return e
}

// OnDragEnd Fired when a drag operation concludes, whether successful (dropped on valid target) or cancelled (Escape key,
// invalid drop zone). Occurs on the dragged element and is useful for cleanup operations, resetting drag states,
// removing visual indicators, or logging drag completion. Always fires after ondrop or dragover events complete.
func (e *element) OnDragEnd(handler string) *element {
	e.SetAttribute("ondragend", handler)
	return e
}

// OnDragEnter Fired when a dragged element first enters a potential drop target. Occurs on the drop target element and is
// commonly used to highlight drop zones, show insertion indicators, or prepare the target for receiving dropped
// content. Often paired with preventing default behavior to indicate the target accepts drops.
func (e *element) OnDragEnter(handler string) *element {
	e.SetAttribute("ondragenter", handler)
	return e
}

// OnDragLeave Fired when a dragged element exits a drop target area. Occurs on the drop target element and is typically used
// to remove drop zone highlights, hide insertion indicators, or reset the target's visual state. Important for
// maintaining clean visual feedback during drag operations and avoiding stuck highlight states.
func (e *element) OnDragLeave(handler string) *element {
	e.SetAttribute("ondragleave", handler)
	return e
}

// OnDragOver Fired repeatedly while a dragged element hovers over a drop target. Essential for enabling drops - must call
// preventDefault() to allow dropping. Used to update drop indicators, determine exact drop position, provide
// visual feedback, or validate whether the current drag data is acceptable for this drop target.
func (e *element) OnDragOver(handler string) *element {
	e.SetAttribute("ondragover", handler)
	return e
}

// OnDragStart Fired when a drag operation begins, triggered by the user starting to drag a draggable element. Occurs on the
// source element being dragged and is used to set drag data with setData(), customize the drag image, define
// allowed drag effects, or prepare the element for dragging. The foundation event for all drag-and-drop
// operations.
func (e *element) OnDragStart(handler string) *element {
	e.SetAttribute("ondragstart", handler)
	return e
}

// OnDrop Fired when a dragged element is successfully dropped on a drop target. Occurs after dragover events and
// represents the completion of a drag-and-drop operation. Used to process the dropped data with getData(), move
// elements, update application state, or trigger follow-up actions. Must call preventDefault() in dragover to
// enable dropping.
func (e *element) OnDrop(handler string) *element {
	e.SetAttribute("ondrop", handler)
	return e
}

// OnDurationChange Fired when the duration of media content becomes available or changes. Occurs on <audio> and <video> elements
// when metadata is loaded or when switching to different media sources. Useful for updating progress bars,
// calculating playback positions, enabling seeking controls, or displaying total media duration to users.
func (e *element) OnDurationChange(handler string) *element {
	e.SetAttribute("ondurationchange", handler)
	return e
}

// OnEmptied Fired when media element is reset to empty state, typically when load() is called to reload media or when the
// source changes. Occurs on <audio> and <video> elements and indicates that previous media data is no longer
// available. Useful for resetting player UI, clearing cached data, showing loading states, or preparing for new
// media content.
func (e *element) OnEmptied(handler string) *element {
	e.SetAttribute("onemptied", handler)
	return e
}

// OnEnded Fired when media playback reaches the end of the content. Occurs on <audio> and <video> elements when the media
// finishes playing naturally (not when paused or stopped by user). Commonly used for playing next track, showing
// replay options, triggering analytics, hiding playback controls, or starting related content.
func (e *element) OnEnded(handler string) *element {
	e.SetAttribute("onended", handler)
	return e
}

// OnInvalid Fired when form validation fails on a submittable element during form submission. Occurs before the form submits
// when built-in HTML5 validation constraints are not met (required, pattern, min/max, etc.). Used for custom
// validation messages, focusing invalid fields, preventing submission, or implementing custom validation UI.
func (e *element) OnInvalid(handler string) *element {
	e.SetAttribute("oninvalid", handler)
	return e
}

// OnKeyDown Fired when a key is pressed down, before any character is generated. Captures all keys including modifiers
// (Ctrl, Alt, Shift), function keys, and arrows. Used for keyboard shortcuts, game controls, navigation,
// preventing default key behavior, or implementing custom key handling. Fires repeatedly when key is held down.
func (e *element) OnKeyDown(handler string) *element {
	e.event().OnKeyDown = handler
	return e
}

// OnKeyPress Fired when a key press results in a character being generated. Only triggers for printable characters, not for
// modifier or function keys. Deprecated in favor of onkeydown and oninput events. Historically used for character
// input validation, but modern applications should use onkeydown for key detection and oninput for content
// changes.
func (e *element) OnKeyPress(handler string) *element {
	e.SetAttribute("onkeypress", handler)
	return e
}

// OnKeyUp Fired when a pressed key is released. Often paired with onkeydown for complete key interaction handling. Used
// for ending keyboard shortcuts, stopping repeated actions, implementing key combinations, detecting when modifier
// keys are released, or triggering actions that should occur after key input is complete.
func (e *element) OnKeyUp(handler string) *element {
	e.event().OnKeyUp = handler
	return e
}

// OnLoadedData Fired when enough media data has loaded to render the first frame. Occurs on <audio> and <video> elements when
// initial media content is available for display. Useful for showing video thumbnails, enabling scrubbing
// controls, displaying media dimensions, or indicating that media is ready for interaction.
func (e *element) OnLoadedData(handler string) *element {
	e.SetAttribute("onloadeddata", handler)
	return e
}

// OnLoadedMetadata Fired when media metadata (duration, dimensions, text tracks) has been loaded. Occurs on <audio> and <video>
// elements before actual media data loads. Useful for setting up player UI, configuring progress bars, enabling
// seeking, displaying video dimensions, or initializing media-dependent features.
func (e *element) OnLoadedMetadata(handler string) *element {
	e.SetAttribute("onloadedmetadata", handler)
	return e
}

// OnLoadStart Fired when the browser begins loading a resource, typically on media elements, images, or during fetch
// operations. Indicates the start of the loading process before any data is actually received. Useful for showing
// loading indicators, starting progress tracking, initializing loading states, or logging load attempts.
func (e *element) OnLoadStart(handler string) *element {
	e.SetAttribute("onloadstart", handler)
	return e
}

// OnMouseDown Fired when a mouse button is pressed down on an element. The first part of a click interaction, followed by
// mouseup. Used for drag operations, custom button effects, games, drawing applications, or implementing custom
// click behaviors. Can distinguish between left, middle, and right mouse buttons.
func (e *element) OnMouseDown(handler string) *element {
	e.SetAttribute("onmousedown", handler)
	return e
}

// OnMouseEnter Fired when the mouse pointer enters an element's boundaries. Does not bubble and only fires once when entering,
// not when moving over child elements. Perfect for hover effects, tooltips, dropdown menus, highlighting
// elements, or triggering UI changes when users mouse over interactive components.
func (e *element) OnMouseEnter(handler string) *element {
	e.SetAttribute("onmouseenter", handler)
	return e
}

// OnMouseLeave Fired when the mouse pointer exits an element's boundaries. Does not bubble and only fires when leaving the
// element, not when moving to child elements. Paired with onmouseenter for clean hover states, hiding tooltips,
// closing dropdowns, or removing highlights when users stop hovering.
func (e *element) OnMouseLeave(handler string) *element {
	e.SetAttribute("onmouseleave", handler)
	return e
}

// OnMouseMove Fired continuously while the mouse moves over an element. Can fire many times per second, so consider throttling
// for performance. Used for mouse tracking, custom cursors, drag operations, drawing applications, interactive
// games, or creating mouse-following effects. Provides precise cursor position data.
func (e *element) OnMouseMove(handler string) *element {
	e.SetAttribute("onmousemove", handler)
	return e
}

// OnMouseOut Fired when the mouse pointer leaves an element or moves to one of its child elements. Unlike onmouseleave, this
// event bubbles and can fire when moving over child elements. Less commonly used than onmouseleave due to its
// bubbling behavior, but useful for specific event delegation scenarios.
func (e *element) OnMouseOut(handler string) *element {
	e.SetAttribute("onmouseout", handler)
	return e
}

// OnMouseOver Fired when the mouse pointer enters an element or moves to one of its child elements. Unlike onmouseenter, this
// event bubbles and can fire multiple times when moving over child elements. Less commonly used than onmouseenter
// due to its bubbling behavior, but useful for event delegation or complex hover tracking.
func (e *element) OnMouseOver(handler string) *element {
	e.SetAttribute("onmouseover", handler)
	return e
}

// OnMouseUp Fired when a mouse button is released after being pressed down. Completes a click interaction when combined
// with mousedown. Used for finishing drag operations, custom button behaviors, click completion handling, or
// implementing mouse-based interactions that require both press and release detection.
func (e *element) OnMouseUp(handler string) *element {
	e.SetAttribute("onmouseup", handler)
	return e
}

// OnMouseWheel Fired when the mouse wheel is scrolled (deprecated in favor of 'wheel' event). Detects vertical and horizontal
// scrolling from mouse wheels or trackpad gestures. Used for custom scrolling behavior, zooming, volume controls,
// image galleries, or implementing scroll-based interactions. Provides delta values for scroll direction and
// amount.
func (e *element) OnMouseWheel(handler string) *element {
	e.SetAttribute("onmousewheel", handler)
	return e
}

// OnPause Fired when media playback is paused, either by user action or programmatically. Occurs on <audio> and <video>
// elements when playback stops but remains ready to resume. Used for updating play/pause buttons, saving playback
// position, pausing related animations, analytics tracking, or triggering pause-related functionality.
func (e *element) OnPause(handler string) *element {
	e.SetAttribute("onpause", handler)
	return e
}

// OnPlay Fired when media playback is requested to start, either by user action or programmatically. Occurs on <audio>
// and <video> elements when transitioning from paused to playing state. Note this fires when play is requested,
// not when actually playing (use onplaying for that). Used for updating UI controls and preparing for playback.
func (e *element) OnPlay(handler string) *element {
	e.SetAttribute("onplay", handler)
	return e
}

// OnPlaying Fired when media playback actually begins after being paused or delayed due to buffering. Occurs on <audio> and
// <video> elements when media is actively playing content. Used for updating player UI, starting progress
// tracking, enabling playback-dependent features, or triggering actions that should occur during active playback.
func (e *element) OnPlaying(handler string) *element {
	e.SetAttribute("onplaying", handler)
	return e
}

// OnProgress Fired periodically during media loading to indicate download progress. Occurs on <audio> and <video> elements
// and provides information about how much content has been buffered. Used for updating progress bars, showing
// buffering indicators, enabling progressive playback, or estimating load completion times.
func (e *element) OnProgress(handler string) *element {
	e.SetAttribute("onprogress", handler)
	return e
}

// OnRateChange Fired when media playback speed changes. Occurs on <audio> and <video> elements when the playbackRate property
// is modified (e.g., 0.5x, 1x, 1.5x, 2x speed). Used for updating speed indicators, adjusting UI controls,
// synchronizing playback-dependent animations, or implementing custom playback speed controls.
func (e *element) OnRateChange(handler string) *element {
	e.SetAttribute("onratechange", handler)
	return e
}

// OnReset Fired when a form is reset to its initial state, either by clicking a reset button or calling the form's
// reset() method. Occurs on <form> elements and provides an opportunity to handle the reset action, clear custom
// validation states, reset dynamic content, or prevent the reset if needed.
func (e *element) OnReset(handler string) *element {
	e.SetAttribute("onreset", handler)
	return e
}

// OnResize Fired when the browser window or element is resized. Commonly used on the window object to handle viewport
// changes, but also available on resizable elements. Essential for responsive design, updating layouts,
// recalculating positions, adjusting canvas sizes, or triggering responsive behavior based on size changes.
func (e *element) OnResize(handler string) *element {
	e.SetAttribute("onresize", handler)
	return e
}

// OnScroll Fired when an element's scroll position changes. Can fire rapidly during scrolling, so consider throttling for
// performance. Used for implementing scroll-based animations, infinite scroll, sticky headers, scroll progress
// indicators, lazy loading, or triggering content updates based on scroll position.
func (e *element) OnScroll(handler string) *element {
	e.SetAttribute("onscroll", handler)
	return e
}

// OnSeeked Fired when a media seek operation completes successfully. Occurs on <audio> and <video> elements after the user
// or code changes the currentTime position and the media has moved to the new location. Used for updating progress
// indicators, resuming playback, hiding seeking UI, or triggering actions after successful time navigation.
func (e *element) OnSeeked(handler string) *element {
	e.SetAttribute("onseeked", handler)
	return e
}

// OnSeeking Fired when a media seek operation begins. Occurs on <audio> and <video> elements when the user or code starts
// changing the currentTime position. Used for showing seeking indicators, pausing dependent animations, updating
// UI to reflect seeking state, or preparing for playback position changes.
func (e *element) OnSeeking(handler string) *element {
	e.SetAttribute("onseeking", handler)
	return e
}

// OnSelect Fired when text is selected within an input field or textarea. Occurs on <input> and <textarea> elements when
// users highlight text. Used for implementing text formatting tools, copy shortcuts, selection-based actions, text
// analysis features, or providing contextual options for selected content.
func (e *element) OnSelect(handler string) *element {
	e.SetAttribute("onselect", handler)
	return e
}

// OnShow Fired when a <dialog> element becomes visible, either through showModal() or show() methods. Used for
// initializing dialog content, setting focus to appropriate elements, starting animations, loading dynamic data,
// or triggering actions that should occur when the dialog opens.
func (e *element) OnShow(handler string) *element {
	e.SetAttribute("onshow", handler)
	return e
}

// OnSort Fired when a sortable list or table is reordered. While not a standard HTML event, it's commonly used in
// sortable libraries and custom implementations. Used for saving sort preferences, updating data models,
// triggering dependent updates, analytics tracking, or implementing custom sort behaviors.
func (e *element) OnSort(handler string) *element {
	e.SetAttribute("onsort", handler)
	return e
}

// OnStalled Fired when media loading stalls due to network issues or server problems. Occurs on <audio> and <video>
// elements when expected data doesn't arrive. Used for showing network error messages, implementing retry logic,
// switching to alternative sources, or providing fallback content when media loading fails.
func (e *element) OnStalled(handler string) *element {
	e.SetAttribute("onstalled", handler)
	return e
}

// OnSuspend Fired when media loading is intentionally suspended, typically when the browser decides it has loaded enough
// data for current needs. Occurs on <audio> and <video> elements as an optimization. Used for managing loading
// states, updating progress indicators, or implementing custom buffering strategies.
func (e *element) OnSuspend(handler string) *element {
	e.SetAttribute("onsuspend", handler)
	return e
}

// OnTimeUpdate Fired regularly during media playback as the currentTime advances. Occurs on <audio> and <video> elements,
// typically 4 times per second during playback. Essential for updating progress bars, synchronized content, time
// displays, subtitle timing, or any functionality that needs to track playback position in real-time.
func (e *element) OnTimeUpdate(handler string) *element {
	e.SetAttribute("ontimeupdate", handler)
	return e
}

// OnToggle Fired when a <details> element is opened or closed by clicking its <summary> or programmatically changing the
// open attribute. Used for lazy loading collapsed content, animating expand/collapse transitions, saving user
// preferences, analytics tracking, or implementing custom accordion behaviors.
func (e *element) OnToggle(handler string) *element {
	e.SetAttribute("ontoggle", handler)
	return e
}

// OnVolumeChange Fired when media volume or muted state changes. Occurs on <audio> and <video> elements when the volume
// property is modified or when toggling between muted and unmuted states. Used for updating volume sliders, mute
// button states, saving user preferences, or synchronizing audio controls across multiple media elements.
func (e *element) OnVolumeChange(handler string) *element {
	e.SetAttribute("onvolumechange", handler)
	return e
}

// OnWaiting Fired when media playback stops due to insufficient buffered data and is waiting for more content to load.
// Occurs on <audio> and <video> elements during playback interruptions. Used for showing buffering spinners,
// reducing quality temporarily, implementing adaptive streaming, or providing user feedback during loading delays.
func (e *element) OnWaiting(handler string) *element {
	e.SetAttribute("onwaiting", handler)
	return e
}

// SetAttribute sets a custom attribute on the element
func (e *element) SetAttribute(key string, value string) {
	if e.attr == nil {
		e.attr = &[]node.Attribute{}
	}
	// Update existing attribute or add new one
	for i, attr := range *e.attr {
		if attr.Key == key {
			(*e.attr)[i].Value = value
			return
		}
	}
	*e.attr = append(*e.attr, node.Attribute{Key: key, Value: value})
}

// Add appends child nodes to the element
func (e *element) Add(nodes ...node.Node) *element {
	e.nodes = append(e.nodes, nodes...)
	return e
}

// Replace replaces all child nodes with the provided nodes
func (e *element) Replace(nodes ...node.Node) *element {
	e.nodes = nodes
	return e
}

// Node interface implementation

// BufferHint sets or gets the buffer size hint for pool allocation.
// When called with a hint, it sets the hint and returns it.
// When called without arguments, it returns the current hint.
// After Render(w), this reflects the actual rendered size.
func (e *element) BufferHint(hint ...int) int {
	if len(hint) > 0 && hint[0] > 0 {
		e.bufferhint = hint[0]
	}
	return e.bufferhint
}

// Render generates the complete HTML representation of the element.
// If a writer is provided, the output is written to it using a pooled buffer and nil is returned.
// If no writer is provided, the output is returned as a byte slice.
func (e *element) Render(w ...io.Writer) []byte {
	if len(w) > 0 && w[0] != nil {
		buf := fluent.NewBuffer(e.bufferhint)
		e.RenderBuilder(buf)
		buf.WriteTo(w[0])
		e.bufferhint = buf.Len()
		fluent.PutBuffer(buf)
		return nil
	}
	var buf bytes.Buffer
	e.RenderBuilder(&buf)
	return buf.Bytes()
}

// AttributeBuilder writes all attributes for the element to the buffer.
func (e *element) AttributeBuilder(buf *bytes.Buffer) {
	if e.name != "" {
		buf.Write(html5.AttrName)
		buf.WriteString(e.name)
		buf.Write(html5.MarkupQuote)
	}
	if e.value != "" {
		buf.Write(html5.AttrValue)
		buf.WriteString(e.value)
		buf.Write(html5.MarkupQuote)
	}
	if len(e.inputType) > 0 {
		buf.Write(html5.AttrType)
		buf.Write(e.inputType)
		buf.Write(html5.MarkupQuote)
	}
	if e.src != "" {
		buf.Write(html5.AttrSrc)
		buf.WriteString(e.src)
		buf.Write(html5.MarkupQuote)
	}
	if len(e.accept) > 0 {
		buf.Write(html5.AttrAccept)
		buf.Write(e.accept)
		buf.Write(html5.MarkupQuote)
	}
	if len(e.autocomplete) > 0 {
		buf.Write(html5.AttrAutoComplete)
		buf.Write(e.autocomplete)
		buf.Write(html5.MarkupQuote)
	}
	if e.checked {
		buf.Write(html5.AttrChecked)
	}
	if e.disabled {
		buf.Write(html5.AttrDisabled)
	}
	if e.maxlength != 0 {
		buf.Write(html5.AttrMaxLength)
		buf.Write(strconv.AppendInt(nil, int64(e.maxlength), 10))
		buf.Write(html5.MarkupQuote)
	}
	if e.placeholder != "" {
		buf.Write(html5.AttrPlaceholder)
		buf.WriteString(e.placeholder)
		buf.Write(html5.MarkupQuote)
	}
	if e.readonly {
		buf.Write(html5.AttrReadOnly)
	}
	if e.required {
		buf.Write(html5.AttrRequired)
	}
	if e.formnovalidate {
		buf.Write(html5.AttrFormNoValidate)
	}
	if e.multiple {
		buf.Write(html5.AttrMultiple)
	}
	if len(e.capture) > 0 {
		buf.Write(html5.AttrCapture)
		buf.Write(e.capture)
		buf.Write(html5.MarkupQuote)
	}
	if len(e.enctype) > 0 {
		buf.Write(html5.AttrFormEncType)
		buf.Write(e.enctype)
		buf.Write(html5.MarkupQuote)
	}
	if len(e.formmethod) > 0 {
		buf.Write(html5.AttrFormMethod)
		buf.Write(e.formmethod)
		buf.Write(html5.MarkupQuote)
	}
	if len(e.popovertargetaction) > 0 {
		buf.Write(html5.AttrPopoverTargetAction)
		buf.Write(e.popovertargetaction)
		buf.Write(html5.MarkupQuote)
	}
	if len(e.target) > 0 {
		buf.Write(html5.AttrFormTarget)
		buf.Write(e.target)
		buf.Write(html5.MarkupQuote)
	}
	if e.class != "" {
		buf.Write(html5.AttrClass)
		buf.WriteString(e.class)
		buf.Write(html5.MarkupQuote)
	}
	if e.id != "" {
		buf.Write(html5.AttrID)
		buf.WriteString(e.id)
		buf.Write(html5.MarkupQuote)
	}
	if e.style != "" {
		buf.Write(html5.AttrStyle)
		buf.WriteString(e.style)
		buf.Write(html5.MarkupQuote)
	}
	if e.title != "" {
		buf.Write(html5.AttrTitle)
		buf.WriteString(e.title)
		buf.Write(html5.MarkupQuote)
	}
	if e.hidden {
		buf.Write(html5.AttrHidden)
	}
	if e.tabindex != 0 {
		buf.Write(html5.AttrTabIndex)
		buf.Write(strconv.AppendInt(nil, int64(e.tabindex), 10))
		buf.Write(html5.MarkupQuote)
	}
	if e.role != "" {
		buf.Write(html5.AttrRole)
		buf.WriteString(e.role)
		buf.Write(html5.MarkupQuote)
	}
	if e.lang != "" {
		buf.Write(html5.AttrLang)
		buf.WriteString(e.lang)
		buf.Write(html5.MarkupQuote)
	}
	if e.accesskey != "" {
		buf.Write(html5.AttrAccessKey)
		buf.WriteString(e.accesskey)
		buf.Write(html5.MarkupQuote)
	}
	if e.autofocus {
		buf.Write(html5.AttrAutoFocus)
	}
	if e.draggable {
		buf.Write(html5.AttrDraggable)
	}
	if e.exportparts != "" {
		buf.Write(html5.AttrExportParts)
		buf.WriteString(e.exportparts)
		buf.Write(html5.MarkupQuote)
	}
	if e.inert {
		buf.Write(html5.AttrInert)
	}
	if e.itemprop != "" {
		buf.Write(html5.AttrItemProp)
		buf.WriteString(e.itemprop)
		buf.Write(html5.MarkupQuote)
	}
	if e.itemref != "" {
		buf.Write(html5.AttrItemRef)
		buf.WriteString(e.itemref)
		buf.Write(html5.MarkupQuote)
	}
	if e.itemscope {
		buf.Write(html5.AttrItemScope)
	}
	if e.part != "" {
		buf.Write(html5.AttrPart)
		buf.WriteString(e.part)
		buf.Write(html5.MarkupQuote)
	}

	if e.attr != nil {
		for _, attr := range *e.attr {
			buf.Write(html5.MarkupSpace)
			buf.WriteString(attr.Key)
			buf.Write(html5.MarkupEquals)
			buf.Write(html5.MarkupQuote)
			buf.WriteString(attr.Value)
			buf.Write(html5.MarkupQuote)
		}
	}

	if e.ga != nil {
		e.ga.AttributeBuilder(buf)
	}

	if e.ea != nil {
		e.ea.AttributeBuilder(buf)
	}
}

// RenderBuilder writes the HTML representation directly to a buffer.
func (e *element) RenderBuilder(buf *bytes.Buffer) {
	buf.Write(html5.TagInput)
	e.AttributeBuilder(buf)
	buf.Write(html5.MarkupSelfCloseTag)
}

// RenderOpen writes the opening tag and attributes to the buffer.
func (e *element) RenderOpen(buf *bytes.Buffer) {
	buf.Write(html5.TagInput)
	e.AttributeBuilder(buf)
	buf.Write(html5.MarkupSelfCloseTag)
}

// RenderClose writes the closing tag to the buffer.
func (e *element) RenderClose(buf *bytes.Buffer) {
	// Self-closing element - no closing tag
}

// Nodes returns a slice of child nodes.
func (e *element) Nodes() []node.Node {
	return e.nodes
}

// Attributes returns a pointer to the underlying attributes slice for direct attribute manipulation.
func (e *element) Attributes() *[]node.Attribute {
	if e.attr == nil {
		slice := make([]node.Attribute, 0, 1)
		e.attr = &slice
	}
	return e.attr
}

