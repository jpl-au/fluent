// Code generated by fluent generator. DO NOT EDIT.

package pre

import (
	"github.com/jpl-au/fluent/html5"
	"strings"
	"github.com/jpl-au/fluent/text"
	"fmt"
	"strconv"
	"bytes"
	"io"
	"github.com/jpl-au/fluent"
	"github.com/jpl-au/fluent/node"
	"github.com/jpl-au/fluent/html5/attr/autocapitalize"
	"github.com/jpl-au/fluent/html5/attr/autocorrect"
	"github.com/jpl-au/fluent/html5/attr/contenteditable"
	"github.com/jpl-au/fluent/html5/attr/dir"
	"github.com/jpl-au/fluent/html5/attr/enterkeyhint"
	"github.com/jpl-au/fluent/html5/attr/inputmode"
	"github.com/jpl-au/fluent/html5/attr/popover"
	"github.com/jpl-au/fluent/html5/attr/spellcheck"
	"github.com/jpl-au/fluent/html5/attr/translate"
	"github.com/jpl-au/fluent/html5/attr/virtualkeyboardpolicy"
	"github.com/jpl-au/fluent/html5/attr/writingsuggestions"
)

// Element is an exported alias for the private element type
type Element = element

// element represents the <pre> HTML element
type element struct {
	nodes []node.Node
	class string
	id string
	attr *[]node.Attribute
	ea *html5.EventAttributes
	ga *html5.GlobalAttributes
	bufferhint int
	tabindex int
	autofocus bool
	draggable bool
	hidden bool
	inert bool
	itemscope bool
}

// global returns the GlobalAttributes, initializing if nil
func (e *element) global() *html5.GlobalAttributes {
	if e.ga == nil {
		e.ga = &html5.GlobalAttributes{}
	}
	return e.ga
}

// event returns the EventAttributes, initializing if nil
func (e *element) event() *html5.EventAttributes {
	if e.ea == nil {
		e.ea = &html5.EventAttributes{}
	}
	return e.ea
}

// New Creates a new pre element with the given child nodes
// Example: pre.New(text.Text("Code"))
// Renders: <pre>Code</pre>
func New(nodes ...node.Node) *element {
	return &element{
		nodes: nodes,
	}
}

// Text Creates a new pre element with text content (HTML-encoded)
// Example: pre.Text("  Indented code  ")
// Renders: <pre>  Indented code  </pre>
func Text(content string) *element {
	return &element{
		nodes: []node.Node{text.Text(content)},
	}
}

// Static Creates a new pre element with static text content
// Example: pre.Static("func main() {}")
// Renders: <pre>func main() {}</pre>
func Static(content string) *element {
	return &element{
		nodes: []node.Node{text.Static(content)},
	}
}

// RawText Creates a new pre element with raw text content as unescaped HTML
// Example: pre.RawText("<code>var x = 1;</code>")
// Renders: <pre><code>var x = 1;</code></pre>
func RawText(content string) *element {
	return &element{
		nodes: []node.Node{text.RawText(content)},
	}
}

// Textf Creates a new pre element with formatted text content (HTML-encoded)
// Example: pre.Textf("Line %d", 42)
// Renders: <pre>Line 42</pre>
func Textf(format string, args ...any) *element {
	return &element{
		nodes: []node.Node{text.Textf(format, args...)},
	}
}

// RawTextf Creates a new pre element with formatted raw text content as unescaped HTML
// Example: pre.RawTextf("<code>%s</code>", "x := 1")
// Renders: <pre><code>x := 1</code></pre>
func RawTextf(format string, args ...any) *element {
	return &element{
		nodes: []node.Node{text.RawTextf(format, args...)},
	}
}


// Class A space-separated list of CSS class names assigned to the element. Classes are the primary mechanism for
// styling elements with CSS and selecting elements with JavaScript. Multiple classes can be applied to create
// flexible, reusable styling systems and enable complex element selection patterns. Essential for
// component-based architectures and maintainable CSS.
func (e *element) Class(class string) *element {
	if e.class == "" {
		e.class = class
	} else {
		e.class = strings.Join([]string{e.class, class}, " ")
	}
	return e
}

// ID Defines a unique identifier that must be unique across the entire document. Used for fragment navigation
// (URL anchors), JavaScript element selection, CSS styling with ID selectors, form label associations, and
// ARIA relationships. IDs have higher CSS specificity than classes and should be used sparingly for truly
// unique elements.
func (e *element) ID(id string) *element {
	e.id = id
	return e
}

// Style Contains inline CSS declarations applied directly to the element with the highest specificity. While convenient
// for dynamic styling and testing, inline styles should be used sparingly as they override external stylesheets
// and make maintenance difficult. Best used for programmatically generated styles, dynamic values, or critical
// above-the-fold styling.
func (e *element) Style(css string) *element {
	if e.global().Style == "" {
		e.global().Style = css
	} else {
		e.global().Style = strings.Join([]string{e.global().Style, css}, "; ")
	}
	return e
}

// Title Contains a text representing advisory information related to the element it belongs to. Such information can
// typically, but not necessarily, be presented to the user as a tooltip.
func (e *element) Title(text string) *element {
	e.global().Title = text
	return e
}

// Hidden An enumerated attribute indicating that the element is not yet, or is no longer, relevant. For example, it can
// be used to hide elements of the page that can't be used until the login process has been completed. The
// browser won't render such elements. This attribute must not be used to hide content that could legitimately
// be shown.
func (e *element) Hidden() *element {
	e.hidden = true
	return e
}

// TabIndex An integer attribute indicating if the element can take input focus (is focusable), if it should participate to
// sequential keyboard navigation, and if so, at what position. It can take several values: a negative value, 0, or
// a positive value.
func (e *element) TabIndex(index int) *element {
	e.tabindex = index
	return e
}

// Role Roles define the semantic meaning of content, allowing screen readers and other tools to present and support
// interaction with an object in a way that is consistent with user expectations of that type of object. roles
// are added to HTML elements using role="role_type", where role_type is the name of a role in the ARIA
// specification.
func (e *element) Role(role string) *element {
	e.global().Role = role
	return e
}

// Lang Helps define the language of an element the language that non-editable elements are in, or the language that
// editable elements should be written in by the user.
func (e *element) Lang(language string) *element {
	e.global().Lang = language
	return e
}

// AccessKey Defines keyboard shortcuts for quick element access, typically activated with Alt+key (varies by browser/OS).
// Accepts space-separated characters, with browsers using the first available key on the current keyboard layout.
// Essential for accessibility and power-user workflows, but should be used thoughtfully to avoid conflicts with
// browser/OS shortcuts.
func (e *element) AccessKey(key string) *element {
	if e.global().AccessKey == "" {
		e.global().AccessKey = key
	} else {
		e.global().AccessKey = strings.Join([]string{e.global().AccessKey, key}, " ")
	}
	return e
}

// Anchor Associates a positioned element with an anchor element for CSS anchor positioning. The value references the ID
// of the element to anchor to, enabling dynamic positioning that follows the anchor element. Part of the CSS
// Anchor Positioning specification, useful for tooltips, popovers, and contextual UI elements that need to stay
// connected to their reference points.
func (e *element) Anchor(id string) *element {
	e.SetAttribute("anchor", id)
	return e
}

// AriaLabel Provides an accessible label for the element that overrides any other labeling (such as text content or
// associated label elements). This is essential for accessibility when the visible text doesn't adequately
// describe the element's purpose. Screen readers and other assistive technologies use this as the primary label
// for the element.
func (e *element) AriaLabel(label string) *element {
	e.global().AriaLabel = label
	return e
}

// SetAria Sets ARIA (Accessible Rich Internet Applications) attributes that provide semantic meaning to elements for
// assistive technologies. ARIA attributes describe element roles, properties, and states that help screen
// readers and other accessibility tools understand and interact with dynamic web content. Essential for creating
// accessible web applications.
func (e *element) SetAria(key string, value string) *element {
	e.SetAttribute("aria-" + key, value)
	return e
}

// AutoCapitalize Controls automatic text capitalization on virtual keyboards (mobile devices). Improves mobile user experience
// by reducing manual capitalization, especially useful for forms collecting names, addresses, and titles.
// Possible values: off, none, on, sentences, words, characters.
func (e *element) AutoCapitalize(value autocapitalize.AutoCapitalize) *element {
	e.global().AutoCapitalize = value
	return e
}

// AutoCorrect Controls automatic spell-checking and text correction on mobile devices and some browsers. Useful for disabling
// corrections in fields where technical terms, codes, or names are entered, or where user input should remain
// exactly as typed.
// Possible values: on, off.
func (e *element) AutoCorrect(value autocorrect.AutoCorrect) *element {
	e.global().AutoCorrect = value
	return e
}

// AutoFocus Automatically focuses the element when the page loads or when a dialog containing it is displayed. Should be
// used sparingly as it can interfere with accessibility tools and user navigation expectations. Most effective
// on primary input fields in forms or search boxes where immediate input is expected. Only one element per
// document should have autofocus.
func (e *element) AutoFocus() *element {
	e.autofocus = true
	return e
}

// ContentEditable An enumerated attribute indicating if the element should be editable by the user. If so, the browser modifies
// its widget to allow editing.
// Possible values: true, false, plaintext-only.
func (e *element) ContentEditable(value contenteditable.ContentEditable) *element {
	e.global().ContentEditable = value
	return e
}

// SetData Forms a class of attributes, called custom data attributes, that allow proprietary information to be exchanged
// between the HTML and its DOM representation that may be used by scripts. All such custom data are available
// via the HTMLElement interface of the element the attribute is set on. The HTMLElement.dataset property gives
// access to them.
func (e *element) SetData(key string, value string) *element {
	e.SetAttribute("data-" + key, value)
	return e
}

// Dir An enumerated attribute indicating the directionality of the element's text.
// Possible values: ltr, rtl, auto.
func (e *element) Dir(direction dir.Dir) *element {
	e.global().Dir = direction
	return e
}

// Draggable An enumerated attribute indicating whether the element can be dragged, using the Drag and Drop API.
// Possible values: true, false.
func (e *element) Draggable() *element {
	e.draggable = true
	return e
}

// EnterKeyHint Hints what action label (or icon) to present for the enter key on virtual keyboards.
// Possible values: enter, done, go, next, previous, search, send.
func (e *element) EnterKeyHint(hint enterkeyhint.EnterKeyHint) *element {
	e.global().EnterKeyHint = hint
	return e
}

// ExportParts Used to transitively export shadow parts from a nested shadow tree into a containing light tree.
func (e *element) ExportParts(parts string) *element {
	e.global().ExportParts = parts
	return e
}

// Inert A boolean value that makes the browser disregard user input events for the element. Useful when click events are
// present.
func (e *element) Inert() *element {
	e.inert = true
	return e
}

// InputMode Provides a hint to browsers about the type of virtual keyboard configuration to use when editing this element
// or its contents. Used primarily on <input> elements, but is usable on any element while in contenteditable
// mode.
// Possible values: none, text, tel, url, email, numeric, decimal, search.
func (e *element) InputMode(mode inputmode.InputMode) *element {
	e.global().InputMode = mode
	return e
}

// Is Allows you to specify that a standard HTML element should behave like a registered custom built-in element.
func (e *element) Is(element string) *element {
	e.SetAttribute("is", element)
	return e
}

// ItemId The unique, global identifier of an item. This attribute is part of the WHATWG HTML Microdata feature.
func (e *element) ItemId(id string) *element {
	e.SetAttribute("itemid", id)
	return e
}

// ItemProp Used to add properties to an item. Every HTML element may have an itemprop attribute specified, where an
// itemprop consists of a name and value pair.
func (e *element) ItemProp(properties string) *element {
	e.global().ItemProp = properties
	return e
}

// ItemRef Properties that are not descendants of an element with the itemscope attribute can be associated with the item
// using an itemref.
func (e *element) ItemRef(refs string) *element {
	e.global().ItemRef = refs
	return e
}

// ItemScope itemscope (usually) works along with itemtype to specify that the HTML contained in a block is about a
// particular item.
func (e *element) ItemScope() *element {
	e.itemscope = true
	return e
}

// ItemType Specifies the URL of the vocabulary that will be used to define itemprops (item properties) in the data
// structure.
func (e *element) ItemType(itemType string) *element {
	e.SetAttribute("itemtype", itemType)
	return e
}

// Nonce A cryptographic nonce ("number used once") which can be used by Content Security Policy to determine whether
// or not a given fetch will be allowed to proceed.
func (e *element) Nonce(value string) *element {
	e.SetAttribute("nonce", value)
	return e
}

// Part A space-separated list of the part names of the element. Part names allows CSS to select and style specific
// elements in a shadow tree via the ::part pseudo-element.
func (e *element) Part(names string) *element {
	if e.global().Part == "" {
		e.global().Part = names
	} else {
		e.global().Part = strings.Join([]string{e.global().Part, names}, " ")
	}
	return e
}

// Popover Used to designate an element as a popover element. Popover elements are hidden via display: none until opened
// via an invoking/control element (i.e., a <button> or <input type="button"> with a popovertarget attribute)
// or a HTMLElement.showPopover() call.
// Possible values: auto, manual.
func (e *element) Popover(value popover.Popover) *element {
	e.global().Popover = value
	return e
}

// Slot Assigns a slot in a shadow DOM shadow tree to an element: An element with a slot attribute is assigned to the
// slot created by the <slot> element whose name attribute's value matches that slot attribute's value.
func (e *element) Slot(name string) *element {
	e.SetAttribute("slot", name)
	return e
}

// SpellCheck An enumerated attribute that defines whether the element may be checked for spelling errors.
// Possible values: true, false.
func (e *element) SpellCheck(value spellcheck.Spellcheck) *element {
	e.global().SpellCheck = value
	return e
}

// Translate An enumerated attribute that is used to specify whether an element's attribute values and the values of its
// Text node children are to be translated when the page is localized, or whether to leave them unchanged.
// Possible values: yes, no.
func (e *element) Translate(value translate.Translate) *element {
	e.global().Translate = value
	return e
}

// VirtualKeyboardPolicy An enumerated attribute used to control the on-screen virtual keyboard behavior on devices such as tablets,
// mobile phones, or other devices where a hardware keyboard may not be available for elements that its content
// is editable (for example, it is an <input> or <textarea> element, or an element with the contenteditable
// attribute set).
// Possible values: auto, manual.
func (e *element) VirtualKeyboardPolicy(policy virtualkeyboardpolicy.VirtualKeyboardPolicy) *element {
	e.global().VirtualKeyboardPolicy = policy
	return e
}

// WritingSuggestions An enumerated attribute indicating if browser-provided writing suggestions should be enabled under the scope of
// the element or not.
// Possible values: true, false.
func (e *element) WritingSuggestions(value writingsuggestions.WritingSuggestions) *element {
	e.global().WritingSuggestions = value
	return e
}

// OnClick Fired when an element is clicked with a pointing device (mouse, trackpad, or touch). The most commonly used event for
// user interactions, triggering actions like navigation, form submission, modal opening, or any interactive behavior.
// Available on virtually all elements, making it the primary event for user interface interactions.
func (e *element) OnClick(handler string) *element {
	e.event().OnClick = handler
	return e
}

// OnChange Fired when the value of a form control has been committed by the user and the element loses focus. Differs from
// oninput which fires on every keystroke. Used on <input>, <select>, and <textarea> elements for form validation,
// data processing, dependent field updates, and saving draft changes. Essential for form workflows and user input
// handling.
func (e *element) OnChange(handler string) *element {
	e.event().OnChange = handler
	return e
}

// OnInput Fired immediately when the value of an input element changes (every keystroke, paste, etc.). Unlike onchange, it
// fires before the element loses focus. Used on <input>, <select>, and <textarea> for real-time validation,
// auto-save, search suggestions, character counters, or live form updates. Perfect for responsive user interfaces.
func (e *element) OnInput(handler string) *element {
	e.event().OnInput = handler
	return e
}

// OnFocus Fired when an element receives focus, typically through clicking, tabbing, or programmatic focus(). Commonly used
// on form elements to show input helpers, highlight fields, display validation messages, auto-select content, or
// trigger contextual UI changes. Essential for accessibility and guided user experiences.
func (e *element) OnFocus(handler string) *element {
	e.event().OnFocus = handler
	return e
}

// OnBlur Fired when an element loses focus, typically when the user clicks elsewhere or tabs to another element. Commonly
// used on form inputs (<input>, <textarea>, <select>) to validate input, save drafts, hide dropdowns, or trigger
// field-specific actions. Essential for form validation workflows and user experience enhancements.
func (e *element) OnBlur(handler string) *element {
	e.event().OnBlur = handler
	return e
}

// OnSubmit Fired when a form is submitted, either by clicking a submit button or pressing Enter in a form field. Occurs on
// <form> elements and provides the last opportunity to validate data, prevent submission with preventDefault(), show
// loading states, or perform custom submission handling like AJAX requests.
func (e *element) OnSubmit(handler string) *element {
	e.event().OnSubmit = handler
	return e
}

// OnLoad Fired when a resource and all its dependencies have finished loading successfully. Commonly used on images,
// scripts, stylesheets, iframes, and the window object. Essential for initializing functionality, showing content,
// removing loading indicators, starting animations, or executing code that depends on loaded resources.
func (e *element) OnLoad(handler string) *element {
	e.SetAttribute("onload", handler)
	return e
}

// OnError Fired when an error occurs during resource loading or processing. Common on images, scripts, stylesheets, media
// elements, and other resources that can fail to load. Essential for error handling, showing fallback content,
// implementing retry logic, logging failures, or providing user-friendly error messages when resources are
// unavailable.
func (e *element) OnError(handler string) *element {
	e.SetAttribute("onerror", handler)
	return e
}

// SetEvent Generic method to add an event using SetEvent(key, value)
func (e *element) SetEvent(key string, value string) *element {
	e.SetAttribute(key, value)
	return e
}

// OnAbort Fired when loading of a resource (image, audio, video, or other media) has been aborted before it completed
// successfully. This occurs when the user navigates away from the page, cancels the download, or when the loading
// is interrupted programmatically. Commonly used on media elements (<audio>, <video>), images (<img>), and objects
// (<object>) to handle interrupted loading states and clean up resources.
func (e *element) OnAbort(handler string) *element {
	e.SetAttribute("onabort", handler)
	return e
}

// OnAutoComplete Fired when an input field's autocomplete functionality successfully provides a suggestion that the user accepts.
// This occurs on <input> elements with autocomplete="on" when the browser's autocomplete dropdown is used to fill
// the field. Useful for tracking user interaction with browser autocomplete features, form analytics, and
// implementing custom behavior when autocomplete values are selected.
func (e *element) OnAutoComplete(handler string) *element {
	e.SetAttribute("onautocomplete", handler)
	return e
}

// OnAutoCompleteError Fired when an input field's autocomplete functionality encounters an error while attempting to provide
// suggestions. This occurs on <input> elements with autocomplete="on" when the browser fails to retrieve or
// process autocomplete data. Useful for error handling in forms, fallback autocomplete implementations, and
// debugging autocomplete issues.
func (e *element) OnAutoCompleteError(handler string) *element {
	e.SetAttribute("onautocompleteerror", handler)
	return e
}

// OnCancel Fired when a <dialog> element is cancelled, typically by pressing the Escape key. This event allows you to handle
// dialog cancellation gracefully, perform cleanup operations, reset form state, or prevent the dialog from closing
// by calling preventDefault(). Useful for confirming unsaved changes before closing modal dialogs.
func (e *element) OnCancel(handler string) *element {
	e.SetAttribute("oncancel", handler)
	return e
}

// OnCanPlay Fired when enough media data has been loaded to begin playback, but not necessarily to play through to the end
// without buffering. Occurs on <audio> and <video> elements when the media is ready to start playing. Useful for
// showing play buttons, enabling media controls, preloading indicators, or triggering autoplay functionality.
func (e *element) OnCanPlay(handler string) *element {
	e.SetAttribute("oncanplay", handler)
	return e
}

// OnCanPlayThrough Fired when enough media data has been loaded to play through to the end without interruption for buffering.
// Occurs on <audio> and <video> elements when the entire media file can be played smoothly. Ideal for hiding
// loading spinners, enabling higher quality playback options, or triggering seamless media experiences.
func (e *element) OnCanPlayThrough(handler string) *element {
	e.SetAttribute("oncanplaythrough", handler)
	return e
}

// OnClose Fired when a <dialog> element is closed, either programmatically or by user action. Unlike oncancel, this event
// fires for all dialog closing methods (close button, form submission, JavaScript close()). Useful for cleanup
// operations, saving dialog state, triggering follow-up actions, or updating the parent page based on dialog
// results.
func (e *element) OnClose(handler string) *element {
	e.SetAttribute("onclose", handler)
	return e
}

// OnContextMenu Fired when the user attempts to open a context menu, typically via right-click, Shift+F10, or long-press on
// touch devices. Can be prevented with preventDefault() to implement custom context menus. Commonly used for
// creating application-specific menus, disabling right-click functionality, or providing contextual actions based
// on the target element.
func (e *element) OnContextMenu(handler string) *element {
	e.SetAttribute("oncontextmenu", handler)
	return e
}

// OnCueChange Fired when the active cues of a TextTrack change, typically in video subtitles, captions, or chapter markers.
// Occurs on <track> elements when different text cues become active during media playback. Useful for implementing
// custom subtitle styling, accessibility features, chapter navigation, or synchronized content based on video
// timestamps.
func (e *element) OnCueChange(handler string) *element {
	e.SetAttribute("oncuechange", handler)
	return e
}

// OnDblClick Fired when an element is double-clicked rapidly (two clicks in quick succession). Commonly used for actions like
// opening files, editing text in place, zooming, or toggling between states. Note that ondblclick typically
// prevents the second onclick event from firing, making it suitable for distinct double-click actions.
func (e *element) OnDblClick(handler string) *element {
	e.SetAttribute("ondblclick", handler)
	return e
}

// OnDrag Fired repeatedly (every few hundred milliseconds) during a drag operation while the user is dragging an element.
// Used on draggable elements to provide visual feedback, update drag ghost images, track drag progress, or
// implement custom drag behaviors. Essential for smooth drag-and-drop interfaces and interactive element
// manipulation.
func (e *element) OnDrag(handler string) *element {
	e.SetAttribute("ondrag", handler)
	return e
}

// OnDragEnd Fired when a drag operation concludes, whether successful (dropped on valid target) or cancelled (Escape key,
// invalid drop zone). Occurs on the dragged element and is useful for cleanup operations, resetting drag states,
// removing visual indicators, or logging drag completion. Always fires after ondrop or dragover events complete.
func (e *element) OnDragEnd(handler string) *element {
	e.SetAttribute("ondragend", handler)
	return e
}

// OnDragEnter Fired when a dragged element first enters a potential drop target. Occurs on the drop target element and is
// commonly used to highlight drop zones, show insertion indicators, or prepare the target for receiving dropped
// content. Often paired with preventing default behavior to indicate the target accepts drops.
func (e *element) OnDragEnter(handler string) *element {
	e.SetAttribute("ondragenter", handler)
	return e
}

// OnDragLeave Fired when a dragged element exits a drop target area. Occurs on the drop target element and is typically used
// to remove drop zone highlights, hide insertion indicators, or reset the target's visual state. Important for
// maintaining clean visual feedback during drag operations and avoiding stuck highlight states.
func (e *element) OnDragLeave(handler string) *element {
	e.SetAttribute("ondragleave", handler)
	return e
}

// OnDragOver Fired repeatedly while a dragged element hovers over a drop target. Essential for enabling drops - must call
// preventDefault() to allow dropping. Used to update drop indicators, determine exact drop position, provide
// visual feedback, or validate whether the current drag data is acceptable for this drop target.
func (e *element) OnDragOver(handler string) *element {
	e.SetAttribute("ondragover", handler)
	return e
}

// OnDragStart Fired when a drag operation begins, triggered by the user starting to drag a draggable element. Occurs on the
// source element being dragged and is used to set drag data with setData(), customize the drag image, define
// allowed drag effects, or prepare the element for dragging. The foundation event for all drag-and-drop
// operations.
func (e *element) OnDragStart(handler string) *element {
	e.SetAttribute("ondragstart", handler)
	return e
}

// OnDrop Fired when a dragged element is successfully dropped on a drop target. Occurs after dragover events and
// represents the completion of a drag-and-drop operation. Used to process the dropped data with getData(), move
// elements, update application state, or trigger follow-up actions. Must call preventDefault() in dragover to
// enable dropping.
func (e *element) OnDrop(handler string) *element {
	e.SetAttribute("ondrop", handler)
	return e
}

// OnDurationChange Fired when the duration of media content becomes available or changes. Occurs on <audio> and <video> elements
// when metadata is loaded or when switching to different media sources. Useful for updating progress bars,
// calculating playback positions, enabling seeking controls, or displaying total media duration to users.
func (e *element) OnDurationChange(handler string) *element {
	e.SetAttribute("ondurationchange", handler)
	return e
}

// OnEmptied Fired when media element is reset to empty state, typically when load() is called to reload media or when the
// source changes. Occurs on <audio> and <video> elements and indicates that previous media data is no longer
// available. Useful for resetting player UI, clearing cached data, showing loading states, or preparing for new
// media content.
func (e *element) OnEmptied(handler string) *element {
	e.SetAttribute("onemptied", handler)
	return e
}

// OnEnded Fired when media playback reaches the end of the content. Occurs on <audio> and <video> elements when the media
// finishes playing naturally (not when paused or stopped by user). Commonly used for playing next track, showing
// replay options, triggering analytics, hiding playback controls, or starting related content.
func (e *element) OnEnded(handler string) *element {
	e.SetAttribute("onended", handler)
	return e
}

// OnInvalid Fired when form validation fails on a submittable element during form submission. Occurs before the form submits
// when built-in HTML5 validation constraints are not met (required, pattern, min/max, etc.). Used for custom
// validation messages, focusing invalid fields, preventing submission, or implementing custom validation UI.
func (e *element) OnInvalid(handler string) *element {
	e.SetAttribute("oninvalid", handler)
	return e
}

// OnKeyDown Fired when a key is pressed down, before any character is generated. Captures all keys including modifiers
// (Ctrl, Alt, Shift), function keys, and arrows. Used for keyboard shortcuts, game controls, navigation,
// preventing default key behavior, or implementing custom key handling. Fires repeatedly when key is held down.
func (e *element) OnKeyDown(handler string) *element {
	e.event().OnKeyDown = handler
	return e
}

// OnKeyPress Fired when a key press results in a character being generated. Only triggers for printable characters, not for
// modifier or function keys. Deprecated in favor of onkeydown and oninput events. Historically used for character
// input validation, but modern applications should use onkeydown for key detection and oninput for content
// changes.
func (e *element) OnKeyPress(handler string) *element {
	e.SetAttribute("onkeypress", handler)
	return e
}

// OnKeyUp Fired when a pressed key is released. Often paired with onkeydown for complete key interaction handling. Used
// for ending keyboard shortcuts, stopping repeated actions, implementing key combinations, detecting when modifier
// keys are released, or triggering actions that should occur after key input is complete.
func (e *element) OnKeyUp(handler string) *element {
	e.event().OnKeyUp = handler
	return e
}

// OnLoadedData Fired when enough media data has loaded to render the first frame. Occurs on <audio> and <video> elements when
// initial media content is available for display. Useful for showing video thumbnails, enabling scrubbing
// controls, displaying media dimensions, or indicating that media is ready for interaction.
func (e *element) OnLoadedData(handler string) *element {
	e.SetAttribute("onloadeddata", handler)
	return e
}

// OnLoadedMetadata Fired when media metadata (duration, dimensions, text tracks) has been loaded. Occurs on <audio> and <video>
// elements before actual media data loads. Useful for setting up player UI, configuring progress bars, enabling
// seeking, displaying video dimensions, or initializing media-dependent features.
func (e *element) OnLoadedMetadata(handler string) *element {
	e.SetAttribute("onloadedmetadata", handler)
	return e
}

// OnLoadStart Fired when the browser begins loading a resource, typically on media elements, images, or during fetch
// operations. Indicates the start of the loading process before any data is actually received. Useful for showing
// loading indicators, starting progress tracking, initializing loading states, or logging load attempts.
func (e *element) OnLoadStart(handler string) *element {
	e.SetAttribute("onloadstart", handler)
	return e
}

// OnMouseDown Fired when a mouse button is pressed down on an element. The first part of a click interaction, followed by
// mouseup. Used for drag operations, custom button effects, games, drawing applications, or implementing custom
// click behaviors. Can distinguish between left, middle, and right mouse buttons.
func (e *element) OnMouseDown(handler string) *element {
	e.SetAttribute("onmousedown", handler)
	return e
}

// OnMouseEnter Fired when the mouse pointer enters an element's boundaries. Does not bubble and only fires once when entering,
// not when moving over child elements. Perfect for hover effects, tooltips, dropdown menus, highlighting
// elements, or triggering UI changes when users mouse over interactive components.
func (e *element) OnMouseEnter(handler string) *element {
	e.SetAttribute("onmouseenter", handler)
	return e
}

// OnMouseLeave Fired when the mouse pointer exits an element's boundaries. Does not bubble and only fires when leaving the
// element, not when moving to child elements. Paired with onmouseenter for clean hover states, hiding tooltips,
// closing dropdowns, or removing highlights when users stop hovering.
func (e *element) OnMouseLeave(handler string) *element {
	e.SetAttribute("onmouseleave", handler)
	return e
}

// OnMouseMove Fired continuously while the mouse moves over an element. Can fire many times per second, so consider throttling
// for performance. Used for mouse tracking, custom cursors, drag operations, drawing applications, interactive
// games, or creating mouse-following effects. Provides precise cursor position data.
func (e *element) OnMouseMove(handler string) *element {
	e.SetAttribute("onmousemove", handler)
	return e
}

// OnMouseOut Fired when the mouse pointer leaves an element or moves to one of its child elements. Unlike onmouseleave, this
// event bubbles and can fire when moving over child elements. Less commonly used than onmouseleave due to its
// bubbling behavior, but useful for specific event delegation scenarios.
func (e *element) OnMouseOut(handler string) *element {
	e.SetAttribute("onmouseout", handler)
	return e
}

// OnMouseOver Fired when the mouse pointer enters an element or moves to one of its child elements. Unlike onmouseenter, this
// event bubbles and can fire multiple times when moving over child elements. Less commonly used than onmouseenter
// due to its bubbling behavior, but useful for event delegation or complex hover tracking.
func (e *element) OnMouseOver(handler string) *element {
	e.SetAttribute("onmouseover", handler)
	return e
}

// OnMouseUp Fired when a mouse button is released after being pressed down. Completes a click interaction when combined
// with mousedown. Used for finishing drag operations, custom button behaviors, click completion handling, or
// implementing mouse-based interactions that require both press and release detection.
func (e *element) OnMouseUp(handler string) *element {
	e.SetAttribute("onmouseup", handler)
	return e
}

// OnMouseWheel Fired when the mouse wheel is scrolled (deprecated in favor of 'wheel' event). Detects vertical and horizontal
// scrolling from mouse wheels or trackpad gestures. Used for custom scrolling behavior, zooming, volume controls,
// image galleries, or implementing scroll-based interactions. Provides delta values for scroll direction and
// amount.
func (e *element) OnMouseWheel(handler string) *element {
	e.SetAttribute("onmousewheel", handler)
	return e
}

// OnPause Fired when media playback is paused, either by user action or programmatically. Occurs on <audio> and <video>
// elements when playback stops but remains ready to resume. Used for updating play/pause buttons, saving playback
// position, pausing related animations, analytics tracking, or triggering pause-related functionality.
func (e *element) OnPause(handler string) *element {
	e.SetAttribute("onpause", handler)
	return e
}

// OnPlay Fired when media playback is requested to start, either by user action or programmatically. Occurs on <audio>
// and <video> elements when transitioning from paused to playing state. Note this fires when play is requested,
// not when actually playing (use onplaying for that). Used for updating UI controls and preparing for playback.
func (e *element) OnPlay(handler string) *element {
	e.SetAttribute("onplay", handler)
	return e
}

// OnPlaying Fired when media playback actually begins after being paused or delayed due to buffering. Occurs on <audio> and
// <video> elements when media is actively playing content. Used for updating player UI, starting progress
// tracking, enabling playback-dependent features, or triggering actions that should occur during active playback.
func (e *element) OnPlaying(handler string) *element {
	e.SetAttribute("onplaying", handler)
	return e
}

// OnProgress Fired periodically during media loading to indicate download progress. Occurs on <audio> and <video> elements
// and provides information about how much content has been buffered. Used for updating progress bars, showing
// buffering indicators, enabling progressive playback, or estimating load completion times.
func (e *element) OnProgress(handler string) *element {
	e.SetAttribute("onprogress", handler)
	return e
}

// OnRateChange Fired when media playback speed changes. Occurs on <audio> and <video> elements when the playbackRate property
// is modified (e.g., 0.5x, 1x, 1.5x, 2x speed). Used for updating speed indicators, adjusting UI controls,
// synchronizing playback-dependent animations, or implementing custom playback speed controls.
func (e *element) OnRateChange(handler string) *element {
	e.SetAttribute("onratechange", handler)
	return e
}

// OnReset Fired when a form is reset to its initial state, either by clicking a reset button or calling the form's
// reset() method. Occurs on <form> elements and provides an opportunity to handle the reset action, clear custom
// validation states, reset dynamic content, or prevent the reset if needed.
func (e *element) OnReset(handler string) *element {
	e.SetAttribute("onreset", handler)
	return e
}

// OnResize Fired when the browser window or element is resized. Commonly used on the window object to handle viewport
// changes, but also available on resizable elements. Essential for responsive design, updating layouts,
// recalculating positions, adjusting canvas sizes, or triggering responsive behavior based on size changes.
func (e *element) OnResize(handler string) *element {
	e.SetAttribute("onresize", handler)
	return e
}

// OnScroll Fired when an element's scroll position changes. Can fire rapidly during scrolling, so consider throttling for
// performance. Used for implementing scroll-based animations, infinite scroll, sticky headers, scroll progress
// indicators, lazy loading, or triggering content updates based on scroll position.
func (e *element) OnScroll(handler string) *element {
	e.SetAttribute("onscroll", handler)
	return e
}

// OnSeeked Fired when a media seek operation completes successfully. Occurs on <audio> and <video> elements after the user
// or code changes the currentTime position and the media has moved to the new location. Used for updating progress
// indicators, resuming playback, hiding seeking UI, or triggering actions after successful time navigation.
func (e *element) OnSeeked(handler string) *element {
	e.SetAttribute("onseeked", handler)
	return e
}

// OnSeeking Fired when a media seek operation begins. Occurs on <audio> and <video> elements when the user or code starts
// changing the currentTime position. Used for showing seeking indicators, pausing dependent animations, updating
// UI to reflect seeking state, or preparing for playback position changes.
func (e *element) OnSeeking(handler string) *element {
	e.SetAttribute("onseeking", handler)
	return e
}

// OnSelect Fired when text is selected within an input field or textarea. Occurs on <input> and <textarea> elements when
// users highlight text. Used for implementing text formatting tools, copy shortcuts, selection-based actions, text
// analysis features, or providing contextual options for selected content.
func (e *element) OnSelect(handler string) *element {
	e.SetAttribute("onselect", handler)
	return e
}

// OnShow Fired when a <dialog> element becomes visible, either through showModal() or show() methods. Used for
// initializing dialog content, setting focus to appropriate elements, starting animations, loading dynamic data,
// or triggering actions that should occur when the dialog opens.
func (e *element) OnShow(handler string) *element {
	e.SetAttribute("onshow", handler)
	return e
}

// OnSort Fired when a sortable list or table is reordered. While not a standard HTML event, it's commonly used in
// sortable libraries and custom implementations. Used for saving sort preferences, updating data models,
// triggering dependent updates, analytics tracking, or implementing custom sort behaviors.
func (e *element) OnSort(handler string) *element {
	e.SetAttribute("onsort", handler)
	return e
}

// OnStalled Fired when media loading stalls due to network issues or server problems. Occurs on <audio> and <video>
// elements when expected data doesn't arrive. Used for showing network error messages, implementing retry logic,
// switching to alternative sources, or providing fallback content when media loading fails.
func (e *element) OnStalled(handler string) *element {
	e.SetAttribute("onstalled", handler)
	return e
}

// OnSuspend Fired when media loading is intentionally suspended, typically when the browser decides it has loaded enough
// data for current needs. Occurs on <audio> and <video> elements as an optimization. Used for managing loading
// states, updating progress indicators, or implementing custom buffering strategies.
func (e *element) OnSuspend(handler string) *element {
	e.SetAttribute("onsuspend", handler)
	return e
}

// OnTimeUpdate Fired regularly during media playback as the currentTime advances. Occurs on <audio> and <video> elements,
// typically 4 times per second during playback. Essential for updating progress bars, synchronized content, time
// displays, subtitle timing, or any functionality that needs to track playback position in real-time.
func (e *element) OnTimeUpdate(handler string) *element {
	e.SetAttribute("ontimeupdate", handler)
	return e
}

// OnToggle Fired when a <details> element is opened or closed by clicking its <summary> or programmatically changing the
// open attribute. Used for lazy loading collapsed content, animating expand/collapse transitions, saving user
// preferences, analytics tracking, or implementing custom accordion behaviors.
func (e *element) OnToggle(handler string) *element {
	e.SetAttribute("ontoggle", handler)
	return e
}

// OnVolumeChange Fired when media volume or muted state changes. Occurs on <audio> and <video> elements when the volume
// property is modified or when toggling between muted and unmuted states. Used for updating volume sliders, mute
// button states, saving user preferences, or synchronizing audio controls across multiple media elements.
func (e *element) OnVolumeChange(handler string) *element {
	e.SetAttribute("onvolumechange", handler)
	return e
}

// OnWaiting Fired when media playback stops due to insufficient buffered data and is waiting for more content to load.
// Occurs on <audio> and <video> elements during playback interruptions. Used for showing buffering spinners,
// reducing quality temporarily, implementing adaptive streaming, or providing user feedback during loading delays.
func (e *element) OnWaiting(handler string) *element {
	e.SetAttribute("onwaiting", handler)
	return e
}

// SetAttribute sets a custom attribute on the element
func (e *element) SetAttribute(key string, value string) {
	if e.attr == nil {
		e.attr = &[]node.Attribute{}
	}
	// Update existing attribute or add new one
	for i, attr := range *e.attr {
		if attr.Key == key {
			(*e.attr)[i].Value = value
			return
		}
	}
	*e.attr = append(*e.attr, node.Attribute{Key: key, Value: value})
}

// Add appends child nodes to the element
func (e *element) Add(nodes ...node.Node) *element {
	e.nodes = append(e.nodes, nodes...)
	return e
}

// Replace replaces all child nodes with the provided nodes
func (e *element) Replace(nodes ...node.Node) *element {
	e.nodes = nodes
	return e
}

// Text adds escaped text content to the element
func (e *element) Text(content string) *element {
	e.nodes = append(e.nodes, text.Text(content))
	return e
}

// Textf adds formatted escaped text content to the element
func (e *element) Textf(format string, args ...any) *element {
	e.nodes = append(e.nodes, text.Text(fmt.Sprintf(format, args...)))
	return e
}

// Static adds static text content to the element (JIT-optimisable)
func (e *element) Static(content string) *element {
	e.nodes = append(e.nodes, text.Static(content))
	return e
}

// RawText adds unescaped HTML content to the element
func (e *element) RawText(content string) *element {
	e.nodes = append(e.nodes, text.RawText(content))
	return e
}

// RawTextf adds formatted unescaped HTML content to the element
func (e *element) RawTextf(format string, args ...any) *element {
	e.nodes = append(e.nodes, text.RawText(fmt.Sprintf(format, args...)))
	return e
}

// Node interface implementation

// BufferHint sets or gets the buffer size hint for pool allocation.
// When called with a hint, it sets the hint and returns it.
// When called without arguments, it returns the current hint.
// After Render(w), this reflects the actual rendered size.
func (e *element) BufferHint(hint ...int) int {
	if len(hint) > 0 && hint[0] > 0 {
		e.bufferhint = hint[0]
	}
	return e.bufferhint
}

// Render generates the complete HTML representation of the element.
// If a writer is provided, the output is written to it using a pooled buffer and nil is returned.
// If no writer is provided, the output is returned as a byte slice.
func (e *element) Render(w ...io.Writer) []byte {
	if len(w) > 0 && w[0] != nil {
		buf := fluent.NewBuffer(e.bufferhint)
		e.RenderBuilder(buf)
		buf.WriteTo(w[0])
		e.bufferhint = buf.Len()
		fluent.PutBuffer(buf)
		return nil
	}
	var buf bytes.Buffer
	e.RenderBuilder(&buf)
	return buf.Bytes()
}

// AttributeBuilder writes all attributes for the element to the buffer.
func (e *element) AttributeBuilder(buf *bytes.Buffer) {
	if e.class != "" {
		buf.Write(html5.AttrClass)
		buf.WriteString(e.class)
		buf.Write(html5.MarkupQuote)
	}
	if e.id != "" {
		buf.Write(html5.AttrID)
		buf.WriteString(e.id)
		buf.Write(html5.MarkupQuote)
	}
	if e.hidden {
		buf.Write(html5.AttrHidden)
	}
	if e.tabindex != 0 {
		buf.Write(html5.AttrTabIndex)
		buf.Write(strconv.AppendInt(nil, int64(e.tabindex), 10))
		buf.Write(html5.MarkupQuote)
	}
	if e.autofocus {
		buf.Write(html5.AttrAutoFocus)
	}
	if e.draggable {
		buf.Write(html5.AttrDraggable)
	}
	if e.inert {
		buf.Write(html5.AttrInert)
	}
	if e.itemscope {
		buf.Write(html5.AttrItemScope)
	}

	if e.attr != nil {
		for _, attr := range *e.attr {
			buf.Write(html5.MarkupSpace)
			buf.WriteString(attr.Key)
			buf.Write(html5.MarkupEquals)
			buf.Write(html5.MarkupQuote)
			buf.WriteString(attr.Value)
			buf.Write(html5.MarkupQuote)
		}
	}

	if e.ga != nil {
		e.ga.AttributeBuilder(buf)
	}

	if e.ea != nil {
		e.ea.AttributeBuilder(buf)
	}
}

// RenderBuilder writes the HTML representation directly to a buffer.
func (e *element) RenderBuilder(buf *bytes.Buffer) {
	buf.Write(html5.TagPre)
	e.AttributeBuilder(buf)
	buf.Write(html5.MarkupCloseTag)
	for _, child := range e.nodes {
		if child != nil {
			child.RenderBuilder(buf)
		}
	}
	buf.Write(html5.TagPreClose)
}

// RenderOpen writes the opening tag and attributes to the buffer.
func (e *element) RenderOpen(buf *bytes.Buffer) {
	buf.Write(html5.TagPre)
	e.AttributeBuilder(buf)
	buf.Write(html5.MarkupCloseTag)
}

// RenderClose writes the closing tag to the buffer.
func (e *element) RenderClose(buf *bytes.Buffer) {
	buf.Write(html5.TagPreClose)
}

// Nodes returns a slice of child nodes.
func (e *element) Nodes() []node.Node {
	return e.nodes
}

// Attributes returns a pointer to the underlying attributes slice for direct attribute manipulation.
func (e *element) Attributes() *[]node.Attribute {
	if e.attr == nil {
		slice := make([]node.Attribute, 0, 1)
		e.attr = &slice
	}
	return e.attr
}

